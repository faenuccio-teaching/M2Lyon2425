import Init.Data.List.Basic
import Init.Data.List.Nat.TakeDrop
import Mathlib.Data.NNReal.Basic
import Mathlib.Data.PNat.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Analysis.Normed.Group.Basic
import Mathlib.Algebra.MonoidAlgebra.Basic
import Mathlib.Data.Int.Interval


section Structures

structure OneNat where
  fst : ‚Ñï

structure TwoNat where
  pair ::
  fst : ‚Ñï
  snd : ‚Ñï

structure Couple where
  left : ‚Ñï
  right : ‚Ñï

structure OneNatOneInt where
  fst : ‚Ñï
  snd : ‚Ñ§

structure Mess (Œ± Œ≤ Œ≥ : Type) [Zero Œ±] [TopologicalSpace Œ≤] [UniformSpace Œ≥] :=--`where` or `:=`
  a : Œ± := 0
  f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ≥
  cont : Continuous (f a)

-- `‚åò`


-- This forgets the label and takes it back.
example (x : OneNat) : TwoNat :=
  {x with snd := x.1}

-- another syntax
example (x : OneNat) : TwoNat where
  __ := x
  snd := x.1

example (x : TwoNat) : OneNat := {x with} --without the `with` the extra-field is not thrown away

example (x : TwoNat) : OneNat where
 __ := x

example (x : OneNat) : Couple := x

example (x : OneNat) : Couple := sorry
  -- {x with left := x.1} fields missing: 'right'
--so, it does not "populate missing fields with the first available type-correct term: labels matter"

example (x : OneNat) : ‚Ñï := sorry--{x with}

structure Mix where
  fst : ‚Ñï
  right : ‚Ñï

#check Mix.mk

def mix1 (x : TwoNat) (y : Couple) : Mix :=
  {x, y with}
/- remember that `x := {x.fst, x.snd}`, `y = {y.left, y.right}`
  and `Mix.mk` takes a `fst : ‚Ñï` and `right : ‚Ñï`: s we need to throw away `x.snd` and `y.left`-/

def mix1' (x : TwoNat) (y : Couple) : Mix where
  __ := x
  __ := y

-- the order does not really matter, it "destructs and reconstructs".
def mix2 (x : TwoNat) (y : Couple) : Mix :=
  {y, x with}


example : mix1 = mix1' := rfl

example : mix1 = mix2 := rfl

-- yet, if there are two identical fields, it is the first that is picked:
def ord (x‚ÇÅ x‚ÇÇ : TwoNat) : Mix := {x‚ÇÅ, x‚ÇÇ with right := 3}

example (x‚ÇÅ x‚ÇÇ : TwoNat) : (ord x‚ÇÅ x‚ÇÇ).fst = x‚ÇÅ.fst := sorry

example (x‚ÇÅ x‚ÇÇ : TwoNat) : (ord x‚ÇÅ x‚ÇÇ).fst = x‚ÇÇ.fst := sorry


-- An example with structures having three terms.
structure Mix' where
  snd : ‚Ñï
  left : ‚Ñï

structure ThreeNat where
  fst : ‚Ñï
  snd : ‚Ñï
  thrd : ‚Ñï

structure Mix‚ÇÉ where
  right : ‚Ñï
  left : ‚Ñï
  thrd : ‚Ñï

/- `x := {x.fst, x.right}`, `y := {y.snd, y.left}`, `z := {z.fst, z.snd, z.thrd}` and `Mix.mk` takes
a `fst : ‚Ñï` and a `right : ‚Ñï`: we need to throw away `x.left`, `y.left`, `z.snd` and `z.thrd`-/
example (x : Mix) (y : Mix') (z : ThreeNat) : Mix‚ÇÉ :=
  {x, y, z with}

-- A final example with a `Prop`-valued field:

#check Mess.mk

def f‚ÇÅ : Mess ‚Ñï ‚Ñï ‚Ñï where
  f := fun a b ‚Ü¶ a + b
  cont := {isOpen_preimage := fun _ _ ‚Ü¶ trivial}
  -- cont := ‚ü®fun _ _ ‚Ü¶ trivial‚ü©

def f‚ÇÇ : Mess ‚Ñï ‚Ñï ‚Ñï where
  f := fun a b ‚Ü¶ a + b
  cont := continuous_of_discreteTopology

-- `Prop`-valued fields disappear by proof irrelevance
example : f‚ÇÅ = f‚ÇÇ := rfl


-- `‚åò`


-- ## Extends


structure Blob extends OneNatOneInt, OneNat
structure Blob' extends OneNatOneInt, TwoNat

structure TwoNatExt extends OneNat where
  snd : ‚Ñï

/- Under the hood, Lean destructs all these terms and reconstructs them "in the right order" ---
 but keeping labels. -/

-- Remember that `Couple` are pairs of left-right naturals.
def TwoExtToCouple : TwoNatExt ‚Üí Couple := by --fun x ‚Ü¶ {left := x.1, right := x.2} -- error! why?
  rintro ‚ü®x, y‚ü© -- by def, `TwoNatExt` extends `OneNat`, so `x : OneNat`. So,
  exact {left := x.1, right := y}

def TwoNatToCouple : TwoNat ‚Üí Couple := fun x ‚Ü¶ {left := x.1, right := x.2}

-- And if there are duplicates? Remember that
-- `structure Mix where`
--   `fst : ‚Ñï`
--   `right : ‚Ñï`

structure ThreeNatExt extends TwoNat, Mix

#print ThreeNatExt

/- Overlapping fields are not duplicated; moreover, whenever possible, fields will coincide with
constructors of the parent structure; in case of overlapping fields, things are destructured. -/
def TwoNatToExt : TwoNat ‚Üí TwoNatExt := fun x ‚Ü¶ {x with}

/- In the above definition, `with` is able to
1. Destruct `x` into `x.fst` and get a `OneNat`, that populates the first field of a `TwoNatExt`
2. Observe that the other field `x.snd` has the right type and label of what is missing. -/

example (x : TwoNat) : TwoNatToExt x = ‚ü®‚ü®x.fst‚ü©, x.snd‚ü© := rfl

/- Remember that `ThreeNatExt extends TwoNat, Mix` and
  `structure Mix where`
        `fst : ‚Ñï`
        `right : ‚Ñï`     -/

#check ThreeNatExt.mk

def M‚ÇÅ : Mix := {fst := 17, right := 11}
def two : TwoNat := {fst := 1, snd := 2}

def three : ThreeNatExt := {M‚ÇÅ, two with}
def three' : ThreeNatExt := {two, M‚ÇÅ with}

example : three.fst = 17 := by rfl
example : three'.fst = 1 := by rfl

/- So in reality Lean is first using the first variable (`M‚ÇÅ` or `two`), possibly throwing away
useless stuff, and then using what follows to complete them. -/

example : three = three' := sorry--rfl -- (they're even different, not simply not `defeq`..._
--  indeed, `three={fst = 17, snd = 2, right = 11}` while `three'={fst = 1, snd = 2, right = 11}`-/


def M‚ÇÇ : Mix := {fst := 13, right := 11}
def trois : ThreeNatExt := {two, M‚ÇÇ with}

example : trois.fst = 1 := rfl

example : three' = trois := rfl -- one uses `M‚ÇÅ`, and the other uses `M‚ÇÇ`.
/- both are `{fst = 1, snd = 2, right = 11}` (the field `left` has been discharged) . -/


-- `‚åò`


/- ### In True Math
We can now go back to what we saw the last weeks: remember that we defined -/

class AddMonoidBad (M : Type) extends Add M, AddZeroClass M

instance : AddMonoidBad ‚Ñï where --created using `:=` ‚Üí `_` ‚Üí üí°
  add := Nat.add
  zero := Nat.zero
  zero_add := Nat.zero_add
  add_zero := Nat.add_zero

instance : AddMonoidBad ‚Ñï := ‚ü®Nat.zero_add, Nat.add_zero‚ü©
-- instance : AddMonoidBad ‚Ñï := ‚ü®Nat.add_zero, Nat.zero_add‚ü© -- order matters!

instance : AddMonoidBad ‚Ñï := {Nat.instAddMonoid with}

instance : AddMonoidBad ‚Ñï where
  __ := Nat.instAddMonoid

end Structures

section AncillarySyntax

open scoped NNReal


-- `‚åò`


def F‚ÇÅ : ‚Ñù ‚Üí ‚Ñù‚â•0 := fun a ‚Ü¶ ‚Äñ a ‚Äñ‚Çä
def F‚ÇÇ : ‚Ñù ‚Üí ‚Ñù‚â•0 := (‚Äñ ¬∑ ‚Äñ‚Çä)

def G‚ÇÅ : ‚Ñï ‚Üí ‚Ñï := (¬∑ + 1)
def G‚ÇÇ : ‚Ñï ‚Üí ‚Ñï := fun x ‚Ü¶ x + 1
def G‚ÇÉ : ‚Ñï ‚Üí ‚Ñï := fun x ‚Ü¶ Nat.succ x

example : F‚ÇÅ = F‚ÇÇ := rfl
example : G‚ÇÅ = G‚ÇÇ := rfl
example : G‚ÇÇ = G‚ÇÉ := rfl

def L‚ÇÅ : Type _ ‚Üí Type _ := (List ¬∑) --
def L‚ÇÇ : Type* ‚Üí Type _ := (List ¬∑)
def L‚ÇÉ : Type* ‚Üí Type* := (List ¬∑)
/-The difference between `Type*` and `Type _` is that the first declares a term in every universe
level, the second requires Lean to infer it automatically. -/


-- `‚åò`


open Real Function

def myInjective (f : ‚Ñï ‚Üí ‚Ñï) : Prop :=
  ‚àÄ {a b : ‚Ñï}, f a = f b ‚Üí a = b

-- def Injective (f : Œ± ‚Üí Œ≤) : Prop :=
--   ‚àÄ ‚¶Éa‚ÇÅ a‚ÇÇ‚¶Ñ, f a‚ÇÅ = f a‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ


lemma myInjective.comp {f g : ‚Ñï ‚Üí ‚Ñï} (hf : myInjective f) (hg : myInjective g) :
    myInjective (f ‚àò g) := by
  intro a b H
  apply hg
  apply hf
  exact H

example (f g : ‚Ñï ‚Üí ‚Ñï) (hf : myInjective f) (hg : ‚àÄ (a b), g a = g b ‚Üí a = b) :
  myInjective (f ‚àò g) := by
  apply myInjective.comp
  exact hf
  exact hg
  exact @hg

/- As "explained" in the error message, `myInjective g` creates variables `a‚Ä† : ‚Ñï` and
`b‚Ä† : ‚Ñï` so that `myInjective g` *is* `g a‚Ä† = g b‚Ä† ‚Üí a‚Ä† = b‚Ä†`and the `‚àÄ` has vanished. -/

example (f g : ‚Ñï ‚Üí ‚Ñï) (hf : Injective f) (hg : ‚àÄ (a b), g a = g b ‚Üí a = b) :
  Injective (f ‚àò g) := by
  apply Injective.comp
  exact hf
  exact hg

example (a b : ‚Ñï) (f : ‚Ñï ‚Üí ‚Ñï) (h_myInj : myInjective f) (h_Inj : Injective f) (hab : f a = f b) :
  True := sorry
  -- have : h_myInj = h_Inj := rfl
  -- have : h_myInj = h_myInj := rfl
  -- have : h_Inj = h_Inj := rfl
  -- have : h_myInj hab = h_myInj hab := rfl
  -- have : h_myInj hab = h_Inj hab := rfl


-- `‚åò`


end AncillarySyntax


noncomputable section

section Exercises

section Ex1
-- ## Exercise 1
open scoped NNReal
--Recall from last lecture the two classes below, and the test-variable `p`:
class NormedModuleBad (M : Type*) [AddCommGroup M] where
  norm_b : M ‚Üí ‚Ñù‚â•0
export NormedModuleBad (norm_b)

notation "‚Äñ" e "‚Äñ‚ÇÄ" => norm_b e

instance (M N : Type*) [AddCommGroup M] [AddCommGroup N] [NormedModuleBad M] [NormedModuleBad N] :
    NormedModuleBad (M √ó N) where
  norm_b := fun ‚ü®m, n‚ü© ‚Ü¶ max ‚Äñm‚Äñ‚ÇÄ ‚Äñn‚Äñ‚ÇÄ

class ModuleWithRel (M : Type*) [AddCommGroup M] where
  rel : M ‚Üí M ‚Üí Prop

export ModuleWithRel (rel)

instance (M N : Type*) [AddCommGroup M] [AddCommGroup N] [ModuleWithRel M] [ModuleWithRel N] :
    ModuleWithRel (M √ó N) where
  rel := fun ‚ü®m1, n1‚ü© ‚ü®m2, n2‚ü© ‚Ü¶ (rel m1 m2) ‚àß (rel n1 n2)

variable (p : ‚àÄ {T : Type}, (T ‚Üí Prop) ‚Üí Prop)
/- When defining a `ModuleWithRel` instance on any `NormedModuleBad` we used the relation "being in the
same ball of radius `1`". Clearly the choice of `1` was arbitrary.

Define an infinite collection of instances of `ModuleWithRel` on any `NormedModuleBad` indexed by
`œÅ : ‚Ñù‚â•0`, and reproduce both the bad and the good example.

There are (at least) two ways:
* Enrich the `NormedModule`'s structure with a `œÅ`: this is straightforward.
* Keep `œÅ` as a variable: this is much harder, both because Lean won't be very happy with a
`class` depending on a variable and because there will *really* be different instances even with
good choices, so a kind of "internal rewriting" is needed. -/

class NMB_r (M : Type) extends AddCommGroup M, NormedModuleBad M where
  œÅ : ‚Ñù‚â•0

instance (M : Type) [NMB_r M] : ModuleWithRel M where
  rel := fun x y ‚Ü¶ ‚Äñx - y‚Äñ‚ÇÄ ‚â§ NMB_r.œÅ M

instance (M N : Type) [NMB_r M] [NMB_r N] : NMB_r (M √ó N) where
  œÅ := max (NMB_r.œÅ M) (NMB_r.œÅ N)

instance (M : Type) [NMB_r M] : ModuleWithRel M where
  rel := fun x y ‚Ü¶ ‚Äñ x - y ‚Äñ‚ÇÄ ‚â§ NMB_r.œÅ M

example (œÅ : ‚Ñù‚â•0) (hp : ‚àÄ M : Type, [NMB_r M] ‚Üí ‚àÄ m : M, p (rel m))
    (M : Type) [NMB_r M] (v : M √ó M) : p (rel v) := by
  specialize hp (M √ó M) v
  -- exact hp
  sorry

class NMG_r (M : Type) extends AddCommGroup M, NormedModuleBad M where
  œÅ : ‚Ñù‚â•0
  rel_œÅ := fun x y ‚Ü¶ norm_b (x - y) ‚â§ œÅ

instance (M : Type) [NMG_r M] : ModuleWithRel M where
  rel := NMG_r.rel_œÅ--fun x y ‚Ü¶ ‚Äñx - y‚Äñ‚ÇÅ ‚â§ NMG_r.œÅ M

instance (M N : Type) [NMG_r M] [NMG_r N] : NMG_r (M √ó N) where
  œÅ := max (NMG_r.œÅ M) (NMG_r.œÅ N)
  norm_b := fun ‚ü®m, n‚ü© ‚Ü¶ max ‚Äñm‚Äñ‚ÇÄ ‚Äñn‚Äñ‚ÇÄ
  rel_œÅ := rel

example /- (œÅ : ‚Ñù‚â•0) -/ (hp : ‚àÄ M : Type, [NMG_r M] ‚Üí ‚àÄ m : M, p (rel m))
    (M : Type) [NMG_r M] (v : M √ó M) : p (rel v) := by
  specialize hp (M √ó M) v
  exact hp

-- ### The hard approach

@[nolint unusedArguments]
def aliasR (M : Type*) (œÅ : ‚Ñù‚â•0) [AddCommGroup M] := M

class AsAliasR (M : Type*) (œÅ : ‚Ñù‚â•0) [AddCommGroup M] :=
  norm_R : M ‚Üí ‚Ñù‚â•0
  rel_R : M ‚Üí M ‚Üí Prop := fun x y ‚Ü¶ norm_R (x - y) ‚â§ œÅ
  equiv : M ‚âÉ aliasR M œÅ := Equiv.refl _

instance (M M' : Type*) (œÅ œÅ' : ‚Ñù‚â•0) [AddCommGroup M] [AddCommGroup M'] [AsAliasR M œÅ]
  [AsAliasR M' œÅ']: AsAliasR (M √ó M') (max œÅ œÅ') where
  norm_R := fun ‚ü®m‚ÇÅ, m‚ÇÅ'‚ü© ‚Ü¶ max (AsAliasR.norm_R œÅ m‚ÇÅ) (AsAliasR.norm_R œÅ' m‚ÇÅ')

instance (M : Type*) (œÅ : ‚Ñù‚â•0) [AddCommGroup M] : AddCommGroup (aliasR M œÅ) :=
  inferInstanceAs (AddCommGroup M)

-- The `ModuleWithRel` instance on every `aliasR`.
@[nolint unusedArguments]
instance (M : Type*) (œÅ : ‚Ñù‚â•0) [AddCommGroup M] [AsAliasR M œÅ] : ModuleWithRel (aliasR M œÅ) where
  rel := @AsAliasR.rel_R M œÅ _ _

variable (p : ‚àÄ {T : Type}, (T ‚Üí Prop) ‚Üí Prop)

example (hp : ‚àÄ M : Type, ‚àÄ œÅ : ‚Ñù‚â•0, [AddCommGroup M] ‚Üí [AsAliasR M œÅ] ‚Üí
    ‚àÄ m : aliasR M œÅ, p (rel m))
    (M : Type) (œÅ : ‚Ñù‚â•0) [AddCommGroup M] [AsAliasR M œÅ] (v : aliasR (M √ó M) œÅ) :
      p (rel (max_self œÅ ‚ñ∏ v)) := by
  specialize hp (M √ó M) (max œÅ œÅ) v
  convert hp
  simp only [eq_rec_constant]

end Ex1

section Ex2
-- ## Exercise 2
/- "Prove the following claims, stated in the section about the non-discrete metric on `‚Ñï`:
1. The uniformity is discrete if the metric is discrete.
2. As uniformities, `ùí´ (idRel) = ‚ä•`.
3. Is the equality `ùí´ (idRel) = ‚ä•` true as filters?
**ANSWER** NO
4. For any `Œ±`, the discrete topology is the bottom element `‚ä•` of the type `TopologicalSpace Œ±`.
**ANSWER** instance : CompleteLattice (TopologicalSpace Œ±) := (gciGenerateFrom Œ±).liftCompleteLattice"
-/
open Metric Filter Classical

example (X : Type*) [MetricSpace X] (hdisc : ‚àÄ x y : X, x ‚â† y ‚Üí dist x y = 1) :
    (uniformity X) = Filter.principal (idRel : Set (X √ó X)) := by
  convert Metric.uniformSpace_eq_bot.mpr ?_
  ¬∑ exact StrictMono.apply_eq_bot_iff fun _ _ a ‚Ü¶ a
  use 1
  simp only [zero_lt_one, true_and]
  intro i j h
  exact ge_of_eq <| hdisc i j h



example (X : Type*) : (‚ä• : UniformSpace X).uniformity = ùìü (idRel) := rfl

end Ex2

section Ex3

/- ## Exercise 3
"In the attached file `PlanMetro.pdf` you find a reduced version of Lyon's subway network. I have
already defined the type of `Stations`.

1. Find a way to formalize lines (both ordered and non-ordered), and the notion for two stations of
being connected by a path.

2. Prove that being connected is an equivalence relation.

3. Prove that if we add a "circle line" connecting all terminus', then every two stations become
connected.

4. Prove that in the above configuration with a "circle line" every trip requires of at most two
changes."
-/


inductive Stations : Type
  | JeanMace : Stations
  | SaxeGambetta : Stations
  | PlaceGuichard : Stations
  | PartDieu : Stations
  | HotelDeVille : Stations
  | CroixPacquet : Stations
  | Perrache : Stations
  | Ampere : Stations
  | Bellecour : Stations
  | Cordeliers : Stations
  | Guillotiere : Stations
  | VieuxLyon : Stations

instance : Inhabited Stations := ‚ü®Stations.PartDieu‚ü©

open Stations List Classical

inductive IsDirection : List Stations ‚Üí Prop
  | c_SN : IsDirection [HotelDeVille, CroixPacquet]
  | b_SN : IsDirection [JeanMace, SaxeGambetta, PlaceGuichard, PartDieu]
  | a_SN : IsDirection [Perrache, Ampere, Bellecour, Cordeliers, HotelDeVille]
  | d_EW : IsDirection [Guillotiere, Bellecour, VieuxLyon]
  | back {L : List Stations} : IsDirection L ‚Üí IsDirection L.reverse

structure Directions where
  stops : List Stations
  isDir : IsDirection stops


def Directions.reverse : Directions ‚Üí Directions :=
  fun D ‚Ü¶ ‚ü®D.stops.reverse, IsDirection.back D.isDir‚ü©

@[simp]
lemma Directions.reverse_eq (D : Directions) : D.reverse.1 = D.1.reverse := rfl

abbrev A_SN : Directions where
  stops := [Perrache, Ampere, Bellecour, Cordeliers, HotelDeVille]
  isDir := IsDirection.a_SN

abbrev C_SN : Directions where
  stops := [HotelDeVille, CroixPacquet]
  isDir := IsDirection.c_SN

abbrev A_NS : Directions where
  stops := [Perrache, Ampere, Bellecour, Cordeliers, HotelDeVille].reverse
  isDir := IsDirection.back IsDirection.a_SN

abbrev B_SN : Directions where
  stops := [JeanMace, SaxeGambetta, PlaceGuichard, PartDieu]
  isDir := IsDirection.b_SN

abbrev D_EW : Directions where
  stops := [Guillotiere, Bellecour, VieuxLyon]
  isDir := IsDirection.d_EW

instance Directions.Setoid : Setoid Directions where
  r := fun L M ‚Ü¶ L.stops = M.stops.reverse ‚à® L.stops = M.stops
  iseqv := by
    constructor
    ¬∑ tauto
    ¬∑ intros
      rw [‚Üê reverse_eq_iff]
      tauto
    ¬∑ intro _ _ _
      rintro (h1 | h1) (_ | _) <;> simp_all

def Lines := Quotient Directions.Setoid

abbrev A : Lines := Quotient.mk'' A_NS
abbrev A'' : Lines := ‚ü¶A_NS‚üß
abbrev A' : Lines := Quotient.mk'' A_SN
abbrev A''' : Lines := Quotient.mk'' A_NS

example : A = A' := by
  rw [Quotient.eq'']
  constructor
  rfl

/-
inductive IsPermitted : Prop
| (S : Stat) => IsPerm [S]
| S , M => IsPerm M=> exist D, [M.last, S] ‚â§ D=> IsPerm M ++ S
| the same with M.head

structure Trip where
L : List Stat
perm : IsPermittes L


-/

-- #synth DecidableEq Directions-- := by infer_instance
-- #help tactic dec

inductive IsQ (L : List Stations) : Prop
  | nom (s : Stations) (_ : L = [s]) : IsQ L
  | two : 2 ‚â§ L.length ‚Üí (‚àÄ s t : Stations, [s, t] <:+: L ‚Üí ‚àÉ D : Directions, [s,t] <:+: D.1) ‚Üí IsQ L

lemma not_nil_Q {L : List Stations} (hL : IsQ L) : L ‚â† [] := by
  rcases hL with _ | H
  ¬∑ simp_all
  ¬∑ rw [‚Üê length_pos_iff_ne_nil]
    exact lt_of_lt_of_le two_pos H



lemma two_append {Œ± : Type} (x y : Œ±) (L M : List Œ±) (hL : L ‚â† []) (hM : M ‚â† []) (H : [x, y] <:+: L ++ M) :
    [x, y] <:+: M ‚à® [x, y] <:+: L ‚à® [x] <:+ L ‚àß [y] <+: M := by sorry

lemma IsQ_trans {L M : List Stations} (hL : IsQ L) (hM : IsQ M) (H : ‚àÉ D : Directions,
    [M.getLast (not_nil_Q hM), L.head (not_nil_Q hL)] <:+: D.1) : IsQ (M ++ L) := by
  let hL' := hL
  let hM' := hM
  rcases hL with ‚ü®s, rfl‚ü© | ‚ü®_, hs‚ü© <;> rcases hM with ‚ü®t, rfl‚ü© | ‚ü®_, ht‚ü©
  ¬∑ apply IsQ.two (by rfl)
    intro x y hxy
    obtain ‚ü®D, hD‚ü© := H
    simp at hD
    use D
    simp at hxy
    apply IsInfix.trans hxy
    exact hD
  ¬∑ apply IsQ.two
    ¬∑ rw [length_append]
      omega
    ¬∑ intro x y hxy
      simp at H
      specialize ht x y
      obtain ‚ü®l‚ÇÅ, l‚ÇÇ, hl‚ü© := hxy
      by_cases h‚ÇÄ : l‚ÇÇ = []
      ¬∑ rw [h‚ÇÄ] at hl
        simp at hl
        rw [append_eq_append_iff] at hl
        rcases hl with ‚ü®l‚ÇÉ, h3, hs‚ü© | ‚ü®_, _, h_abs‚ü©
        ¬∑ rw [cons_eq_append] at hs
          simp at hs
          obtain ‚ü®l‚ÇÑ, h4, hy‚ü© := hs
          have hy' := hy
          apply_fun List.length at hy
          simp at hy
          rw [hy] at h4 hy'
          simp at hy'
          rw [h4] at h3
          replace h3 : M.getLast (not_nil_Q hM') = x := by
            rw [‚Üê getLast_append_singleton (a := x) l‚ÇÅ]
            congr
          rw [h3, ‚Üê hy'] at H
          exact H
        ¬∑ exfalso
          apply_fun List.length at h_abs
          simp at h_abs
      ¬∑ rw [append_eq_append_iff] at hl
        rcases hl with ‚ü®l‚ÇÉ, h3, hs‚ü© | ‚ü®l‚ÇÉ, hM‚ÇÄ, h_abs‚ü©
        . apply ht
          refine ‚ü®l‚ÇÅ, l‚ÇÉ, h3.symm‚ü©
        ¬∑ apply_fun List.length at h_abs
          simp at h_abs
          have h3 : l‚ÇÉ = [] := by
            apply eq_nil_of_length_eq_zero
            rw [‚Üê ne_eq, ‚Üê length_pos_iff_ne_nil] at h‚ÇÄ
            omega
          rw [h3] at hM‚ÇÄ
          apply ht
          refine ‚ü®l‚ÇÅ, [], by simp [hM‚ÇÄ]‚ü©



      -- rw [append_eq_append_iff] at hl
      -- rcases hl with ‚ü®l‚ÇÉ, h3, _‚ü© | ‚ü®l‚ÇÉ, hk, h3‚ü©
      -- ¬∑ apply ht
      --   refine ‚ü®l‚ÇÅ, l‚ÇÉ, h3.symm‚ü©
      -- ¬∑ by_cases h‚ÇÄ : l‚ÇÉ = []
      --   ¬∑ rw [h‚ÇÄ] at h3 hk
      --     simp at h3 hk








  ¬∑ apply IsQ.two
    ¬∑ rw [length_append]
      omega
    ¬∑ intro x y hxy
      simp at H
      specialize hs x y
      sorry
  ¬∑ apply IsQ.two
    ¬∑ rw [length_append]
      omega
    ¬∑ intro x y hxy
      have := two_append x y M L (not_nil_Q hM') (not_nil_Q hL') hxy
      rcases this with h | h | ‚ü®hx, hy‚ü©
      ¬∑ exact hs x y h
      ¬∑ exact ht x y h
      ¬∑ replace hy := hy.head_eq (by simp)
        rw [‚Üê hy] at H
        have : M.getLast (not_nil_Q hM') = x := by
          obtain ‚ü®l, hl‚ü© := hx
          convert getLast_append_singleton (a := x) l
          exact hl.symm
        rw [this] at H
        simp at H
        exact H

lemma isQ_symm {L : List Stations} (hL : IsQ L) : IsQ L.reverse := by
  rcases hL with ‚ü®s, hs‚ü© | ‚ü®_, H‚ü©
  ¬∑ apply IsQ.nom s
    simp [hs]
  ¬∑ apply IsQ.two
    ¬∑ simp_all
    intro s t hst
    -- rw [‚Üê reverse_reverse [s, _]] at hst
    specialize H t s _
    have := IsInfix.reverse hst
    simp at this
    exact this
    obtain ‚ü®D, hD‚ü© := H
    use D.reverse
    sorry

  structure Trip (start arrival : Stations) where
  stops : List Stations
  permitted : IsQ stops-- not_empty : stops ‚â† []
  start : stops.head (not_nil_Q permitted) = start
  arrival : stops.getLast (not_nil_Q permitted) = arrival

def Connected : Stations ‚Üí Stations ‚Üí Prop := fun S A ‚Ü¶ Nonempty (Trip S A)

example : Connected JeanMace SaxeGambetta := by
  use [JeanMace, SaxeGambetta]
  ¬∑ refine IsQ.two (by rfl) (fun s t hst ‚Ü¶ ?_)
    rw [IsInfix.eq_of_length hst (by rfl)]
    exact ‚ü®B_SN, ‚ü®[], [PlaceGuichard, PartDieu], by rfl‚ü©‚ü©
  all_goals rfl

example : Connected Ampere Guillotiere  := by
  use [Ampere, Bellecour, Guillotiere]
  ¬∑ refine IsQ.two (by decide) (fun s t ‚ü®l‚ÇÅ, l‚ÇÇ, H‚ü© ‚Ü¶ ?_)
    rcases l‚ÇÅ with _ | ‚ü®u, xu‚ü©
    ¬∑ exact ‚ü®A_SN, [Perrache], [Cordeliers, HotelDeVille], by simp_all‚ü©
    ¬∑ simp at H
      replace H := H.2
      rcases xu with _ | ‚ü®v, xv‚ü©
      ¬∑ simp at H
        rw [H.1, H.2.1]
        use D_EW.reverse
        simp
        use [VieuxLyon]
        use []
        rfl
      ¬∑ simp at H
        replace H := H.2
        simp at H
        exfalso
        apply_fun List.length at H
        simp at H
        omega
  all_goals rfl

example : ¬¨ Connected VieuxLyon PartDieu := by sorry --use `injection` tactic?

def ConnectedEquiv : Equivalence Connected where
  refl := by
    intro s
    sorry
  symm := by
    intro s t ‚ü®trip, permitted, start, arrival‚ü©
    have := isQ_symm permitted
    use trip.reverse
    rw [head_reverse]


  trans := sorry

lemma IsQ_of_subDir {L : List Stations} (hL_ne : L ‚â† []) {D : Directions} (hL : L <+ D.1) :
  IsQ L := by sorry--use `<+` and not only `<:+:` **FALSO**
  -- obtain ‚ü®ix, h1, h2‚ü© := sublist_eq_map_getElem hL
  -- have ffx : 0 < ix.length := sorry
  -- let M := (D.1.drop ix[0]).take (ix[0] - L.length)
  -- -- have hM : M <:+: D.1 := sorry
  -- by_cases ind : L.length = 1-- match L with
  -- ¬∑ sorry
  -- ¬∑ replace ind : 2 ‚â§ L.length := by
  --     simp_all
  --     sorry
  --   apply IsQ.two ind
  --   rintro s t ‚ü®l‚ÇÅ, l‚ÇÇ, h‚ü©
  --   use D
  --   use l‚ÇÅ
  --   use l‚ÇÇ
  --   sorry


  -- | [s] => apply IsQ.nom s rfl
  -- | x :: l :: y =>
  --   apply IsQ.two (by simp)
  --   intro s t hst


  -- let _ := @map_getElem_sublist (l := D.1) idx h2

-- lemma Connected_of_subDir (s t : Stations) (D : Directions) (hst : [s, t] <+ D.1) :
--     Connected s t := by sorry


lemma isDirections_ne_nil {L : List Stations} (hL : IsDirection L) : L ‚â† [] := by
  induction hL <;> simpa -- try with cases!

lemma Directions_ne_nil (D : Directions) : D.1 ‚â† [] := isDirections_ne_nil D.2

def terminus (D : Directions) : Stations := D.1.getLast (Directions_ne_nil D)

axiom circle : IsDirection
  [CroixPacquet, HotelDeVille, VieuxLyon, Perrache, Guillotiere, JeanMace, PartDieu]

def CircleLine : Directions where
  stops := [CroixPacquet, HotelDeVille, VieuxLyon, Perrache, Guillotiere, JeanMace, PartDieu]
  isDir := circle

lemma exists_Direction (s : Stations) : ‚àÉ D : Directions, s ‚àà  D.1 := by
  induction s
  all_goals try {use B_SN ; simp_all}
  all_goals try {use A_NS ; simp_all}
  all_goals try {use C_SN ; simp_all}
  all_goals try {use D_EW; simp_all}

lemma getLast_eq_drop_length_sub_one {Œ± : Type} {L : List Œ±} (hL : L ‚â† []) :
    L.drop (L.length - 1) = [L.getLast hL] := by
  replace hL := length_pos.mpr hL
  rw [drop_eq_getElem_cons (by omega)]
  simp only [getLast_eq_getElem, cons.injEq, drop_eq_nil_iff_le, true_and]
  omega



lemma connected_to_terminus (s : Stations) : ‚àÉ D, Connected s (terminus D) := by
  obtain ‚ü®D, hD‚ü© := exists_Direction s
  use D
  obtain ‚ü®n, hn‚ü© := List.get_of_mem hD
  set L := D.1.drop n with hL
  use L
  ¬∑ by_cases hn‚ÇÄ : n < D.1.length - 1
    ¬∑ apply IsQ.two
      ¬∑ rw [hL, length_drop]
        omega
      ¬∑ intro s t ‚ü®l‚ÇÅ, l‚ÇÇ, hlD‚ü©
        use D
        let M := D.1.take n
        have : M ++ L = D.1 := by apply take_append_drop
        use M ++ l‚ÇÅ
        use l‚ÇÇ
        rwa [append_assoc, append_assoc, ‚Üê append_assoc l‚ÇÅ _ _, hlD]
    ¬∑ replace hn‚ÇÄ : n = D.1.length - 1 := by
        apply eq_of_le_of_le
        ¬∑ have := n.2
          rw [Nat.le_sub_one_iff_lt]
          exact this
          omega
        ¬∑ rw [not_lt] at hn‚ÇÄ
          exact hn‚ÇÄ
      rw [hn‚ÇÄ, getLast_eq_drop_length_sub_one <| Directions_ne_nil D] at hL
      exact IsQ.nom _ hL
  ¬∑ simp_rw [hL]
    rw [List.head_drop]
    exact hn
  ¬∑ rw [List.getLast_drop]
    rfl


-- lemma Terminus_Connected {D‚ÇÅ D‚ÇÇ : Directions} {s t : Stations} (hs : s = terminus D‚ÇÅ)
--     (ht : t = terminus D‚ÇÇ) : Connected s t := by
--   by_cases hdir : D‚ÇÅ = D‚ÇÇ
--   ¬∑ rw [hdir] at hs
--     apply Connected_rfl

lemma Everything_Connected (s t : Stations) : Connected s t := by sorry
  -- obtain ‚ü®D1, h1‚ü© := connected_to_terminus s
  -- obtain ‚ü®D2, h2‚ü© := connected_to_terminus t
  -- use D1.1 ++ D2.1
  -- apply IsQ_trans
  -- ¬∑ sorry
  -- ¬∑ sorry








#exit




inductive IsPermitted : List Stations ‚Üí Prop
  | no_move (S : Stations) : IsPermitted [S]
  -- | after_last (S : Stations) (M : List Stations) (hM : M ‚â† []) (D : Directions) :
  --     IsPermitted M ‚Üí (M.getLast hM /- hM -/) :: [S] <:+: D.1 ‚Üí IsPermitted (M ++ [S]) -- M ++ [S] is `simp` normal form for `M.concat S`
  | before_head (S : Stations) (M : List Stations) (hM : M ‚â† []) (D : Directions) :
      IsPermitted M ‚Üí S :: [M.head hM] <:+: D.1 ‚Üí IsPermitted (S :: M)


lemma isPermitted.ne_nil {L : List Stations} (hL : IsPermitted L) : L ‚â† [] := by
  cases hL <;> simp



inductive IsP : List Stations ‚Üí Prop
  | no_move (S : Stations) : IsP [S]
  | after_last (M N : List Stations) (D : Directions)  (M_ne : M ‚â† []) (N_ne : N ‚â† []) :
      IsP M ‚Üí IsP N ‚Üí (M.getLast M_ne) :: [N.head N_ne] <:+: D.1 ‚Üí IsP (M ++ N) -- M ++ [S] is `simp` normal form for `M.concat S`

lemma foo {L : List Stations} (hL : IsPermitted L) : IsP L := by
  rcases hL with _ | ‚ü®s, M, hM, D, H‚ü©
  ¬∑ exact IsP.no_move _
  ¬∑ apply IsP.after_last _ _ D (isPermitted.ne_nil H)
    ¬∑ apply foo H
    ¬∑ exact IsP.no_move _
    ¬∑ simpa
    ¬∑ simp
  termination_by L.length
    -- ¬∑ sorry

lemma bar {L : List Stations} (hL : IsP L) : IsPermitted L := by
  rcases hL with _ | ‚ü®M, N, D, M_ne, N_ne, hM‚ü©
  ¬∑ exact IsPermitted.no_move _
  ¬∑ match N with
    | [s] =>
      apply IsPermitted.after_last
      apply bar hM
      assumption
    | s :: xs =>
      by_cases hxs : xs = []
      ¬∑ rw [hxs]
        apply IsPermitted.after_last s M M_ne D (bar hM)
        assumption
      ¬∑ have h_ex : M ++ s :: xs = M ++ ([s]) ++ [(xs.getLast hxs)] := sorry
        rw [h_ex]
        apply IsPermitted.after_last (xs.getLast hxs) (M ++ [s]) (by simp) D
        ¬∑ apply IsPermitted.after_last s M M_ne D (bar hM)
          sorry
        ¬∑ sorry
      termination_by L.length
      -- termination_by M.length
      -- rw [append_cons
      -- rw [append_cons]
      -- rw [‚Üê concat_append]
      -- apply IsPermitted.before_head
  -- termination_by L.length



-- inductive IsP : List Stations ‚Üí Prop
--   | no_move (S : Stations) : IsP [S]
--   | findD (L : List Stations) (D : Directions) (s t : Stations) :
--     [s, t] <:+: L ‚Üí [s, t] <:+: D.1 ‚Üí IsP L

-- lemma empty_not_isP : ¬¨ IsP [] := by
--   intro habs
  -- cases habs
  -- cases habs
  -- aesop

open IsP

lemma isP_ne_nil {L : List Stations} (hL : IsP L) : L ‚â† [] := by
  cases hL <;> simp_all

lemma isP_trans {M N : List Stations} (hM : IsP M) (hN : IsP N) (D : Directions) :
    (M.getLast (isP_ne_nil hM)) :: [N.head (isP_ne_nil hN)] <:+: D.1 ‚Üí IsP (M ++ N) := by
  intro H
  apply after_last _ _ D (isP_ne_nil hM) (isP_ne_nil hN) hM hN
  exact H

lemma iP_refl (s : Stations) : IsP [s] := no_move _

-- lemma isP_symm {L : List Stations} (hL : IsP L) : IsP L.reverse := by
--   rcases hL with s | ‚ü®M, N, D, M_me, N_ne, hM, hN, H‚ü©
--   ¬∑ simp
--     exact no_move _
--   ¬∑ simp
--     induction' M with x xs h_ind_M
--     ¬∑ simp
--       induction' N with y yx h_ind_N
--       ¬∑ simpa
--       ¬∑ simp
--         exfalso
--         apply M_me
--         rfl
--     ¬∑ have N_e : N.reverse ‚â† [] := sorry
--       have xx_e : (x :: xs).reverse ‚â† [] := sorry
--       apply after_last _ _ D.reverse N_e xx_e
--       ¬∑ apply isP_symm hN
--       ¬∑ apply isP_symm hM
--       ¬∑ simp
--         sorry








    -- have h1 : M.length < (N.reverse ++ M.reverse).length := sorry
    -- have h2 : N.length < (N.reverse ++ M.reverse).length := sorry
    -- apply after_last N.reverse M.reverse D.reverse ?_ ?_
    -- apply isP_symm hN
    -- apply isP_symm hM
    -- sorry
    -- simpa [reverse_eq_nil_iff] using isP_ne_nil hN
    -- simpa [reverse_eq_nil_iff] using isP_ne_nil hM
  -- termination_by (N.reverse ++ M.reverse).length



-- lemma refl_isP (s : Stations) : IsP [s] := no_move s

-- lemma refl_isP' (s : Stations) : IsP [s, s] := by
--   cases s
--   ¬∑ apply findD _ _ JeanMace JeanMace
--     ¬∑ simp
--     ¬∑

-- lemma trans_isP {L M : List Stations} (hL : IsP L) (hM : IsP M)
--     (H : L.head (isP_not_empty hL) = M.getLast (isP_not_empty hM)) : IsP (L ++ M) := by
--   rcases hM with s | as
--   ¬∑ rcases hL with x | ax
--     simp at H
--     rw [H]
--     simp




open IsPermitted

lemma IsPermitted_rfl (S : Stations) : IsPermitted [S] := no_move S

-- lemma IsPermitted_symm {L : List Stations} (hL : IsPermitted L) : IsPermitted L.reverse := by
--   rcases hL with _ | ‚ü®S, M, D, hM, hDM‚ü© | ‚ü®S, M, D, hM, hDM‚ü©
--   ¬∑ simpa using IsPermitted.no_move _
--   ¬∑ simp only [reverse_append, reverse_cons, reverse_nil, nil_append, singleton_append]
--     apply before_head _ _ D.reverse
--     ¬∑ apply IsPermitted_symm hM
--     ¬∑ simp
--       rwa [‚Üê List.reverse_infix, reverse_reverse, ‚Üê getLastD_eq_getLast?]
--   ¬∑ rw [reverse_cons/- , ‚Üê concat_eq_append -/]
--     apply IsPermitted.after_last _ _ D.reverse
--     ¬∑ apply IsPermitted_symm hM
--     ¬∑ rw [‚Üê List.reverse_infix, /- reverse_reverse, -/ getLastD_eq_getLast?]
--       simp
--       convert hDM

--   termination_by L.length
open isPermitted

lemma two_append {Œ± : Type} (x y : Œ±) (L M : List Œ±) (hL : L ‚â† []) (hM : M ‚â† []) (H : [x, y] <:+: L ++ M) :
    [x, y] <:+: M ‚à® [x, y] <:+: L ‚à® [x] <:+ L ‚àß [y] <+: M := by sorry
  -- obtain ‚ü®l‚ÇÅ, l‚ÇÇ, H‚ü© := H
  -- rw [append_eq_append_iff] at H
  -- rcases H with ‚ü®l‚ÇÉ, H1, H2‚ü© | ‚ü®l‚ÇÉ, H1, H2‚ü©
  -- ¬∑ right
  --   left
  --   use l‚ÇÅ
  --   use l‚ÇÉ
  --   exact H1.symm
  -- ¬∑ rw [append_eq_append_iff] at H1
  --   rcases H1 with ‚ü®l‚ÇÑ, h1, h2‚ü© | ‚ü®l‚ÇÑ, _, H‚ü©
  --   ¬∑ right
  --     right
  --     sorry


    -- by_cases h_emp : l‚ÇÑ = []
    -- ¬∑ sorry
    -- ¬∑ right
    --   right
    --   constructor
    --   ¬∑ replace h2 : [x] <+: l‚ÇÑ := by --[x, y] = l‚ÇÑ ++ l‚ÇÉ
    --       rw [cons_eq_append] at h2
    --       simp only [h_emp, false_and, false_or] at h2
    --       obtain ‚ü®l‚Çá, h7, h8‚ü© := h2
    --       by_cases H8 : l‚Çá = []
    --       ¬∑ use l‚Çá
    --         rw [H8, append_nil]
    --         rw [H8] at h7
    --         exact h7.symm
    --       ¬∑ use l‚Çá
    --         sorry
    --     obtain ‚ü®l‚ÇÖ, h‚ü© := h2
    --     rw [‚Üê h] at h1
    --     rw [‚Üê append_assoc] at h1
    --     use l‚ÇÅ ++ l‚ÇÖ
    --     exact h1.symm
    --   ¬∑ sorry

    -- ¬∑ rw [H] at H2
    --   left
    --   use l‚ÇÑ
    --   use l‚ÇÇ
    --   exact H2.symm


lemma isPermitted_of_subDir (D : Directions) (L : List Stations) (L_ne : L ‚â† []) (h : L <:+: D.1) :
    IsPermitted L := by
  match L with
  | [s] => exact IsPermitted.no_move _
  | s :: xs =>
    by_cases hxs : xs = []
    ¬∑ rw [hxs]
      exact IsPermitted.no_move _
    ¬∑ apply IsPermitted.before_head s xs hxs D _
      rw [infix_iff_prefix_suffix] at h ‚ä¢
      obtain ‚ü®t, ht1, ht2‚ü© := h
      refine ‚ü®t, ?_, ht2‚ü©
      apply IsPrefix.trans _ ht1
      ¬∑ simp
        convert List.take_prefix 1 xs using 1
        cases xs
        ¬∑ simp
          tauto
        ¬∑ simp only [head_cons, take_succ_cons, take_zero]
      ¬∑ have : xs <:+: D.1 := by
          obtain ‚ü®l‚ÇÅ, l‚ÇÇ, H‚ü© := h
          use l‚ÇÅ ++ [s]
          use l‚ÇÇ
          rw [‚Üê H, append_assoc, append_assoc, append_assoc, append_right_inj, ‚Üê append_assoc,
            append_left_inj]
          rfl
        exact isPermitted_of_subDir D xs hxs this


          -- use xs ++ l‚ÇÇ

      -- ¬∑ simp only [cons_prefix_cons, true_and]
      --   apply prefix_me

      -- have : [s, xs.head hxs] = s :: [xs.head hxs] := rfl
      -- rw [this]

lemma IsPermitted_trans (M N : List Stations) (hM : IsPermitted M) (hN : IsPermitted N)
    (D : Directions) (h : M.getLast (ne_nil hM) :: [N.head (ne_nil hN)] <:+: D.1) :
    IsPermitted (M ++ N) := by
  match M with
  | [s] =>
    apply IsPermitted.before_head _ _ (isPermitted.ne_nil hN) D hN
    exact h
  | s :: xs =>
    rcases hM with _ | ‚ü®_, _, xs_ne, D‚ÇÄ, h_xs, h‚ÇÄ‚ü©
    ¬∑ apply IsPermitted.before_head
      simp
      exact hN
      simp
      simp at h
      exact h
      simp
      exact isPermitted.ne_nil hN
    match N with
    | [t] =>
        apply IsPermitted.before_head
        swap
        ¬∑ convert h‚ÇÄ using 1
          simp
          exact head_append_of_ne_nil xs_ne
        ¬∑ sorry
    | t :: xt => sorry


    -- ¬∑ apply IsPermitted_trans
    --   ¬∑ exact h
    --   ¬∑ apply IsPermitted.before_head _ _ _ _ h_xs h‚ÇÄ
    --   ¬∑ exact hN














#exit
structure Trip (start arrival : Stations) where
  stops : List Stations
  not_empty : stops ‚â† []
  start : stops.head not_empty = start
  arrival : stops.getLast not_empty = arrival
  -- nodup : stops.Nodup
  connection (l : List Stations) : IsInfix l stops ‚Üí l.length = 2 ‚Üí
    ‚àÉ D : Directions, IsInfix l D.stops

def Connected (S A : Stations) : Prop := Nonempty (Trip S A)

lemma Connected_symm (stat : Stations) : Connected stat stat := by
  use [stat] <;> try simp
  intro l hl _
  have := hl.length_le
  simp_all

lemma Connected_rfl {pt‚ÇÅ pt‚ÇÇ} (h : Connected pt‚ÇÅ pt‚ÇÇ) : Connected pt‚ÇÇ pt‚ÇÅ := by
  let t := choice h
  use t.stops.reverse
  ¬∑ simp [t.not_empty]
  ¬∑ simp [t.arrival]
  ¬∑ simp [t.start]
  -- ¬∑ simp [t.nodup]
  ¬∑ intro l hl htwo
    replace hl := reverse_reverse _ ‚ñ∏ hl.reverse
    obtain ‚ü®D, hD‚ü© := t.connection l.reverse hl (htwo ‚ñ∏ length_reverse _)
    exact ‚ü®D.reverse, l.reverse_reverse.symm ‚ñ∏ hD.reverse‚ü©


lemma Connected_trans {pt‚ÇÅ pt‚ÇÇ pt‚ÇÉ} (h12 : Connected pt‚ÇÅ pt‚ÇÇ) (h23 : Connected pt‚ÇÇ pt‚ÇÉ) :
  Connected pt‚ÇÅ pt‚ÇÉ := by
  constructor
  let t12 := choice h12
  let t23 := choice h23
  use t12.stops ++ t23.stops
  ¬∑ simp [t12.not_empty]
  ¬∑ rw [head_append_of_ne_nil]
    exact t12.start
  ¬∑ rw [getLast_append_of_ne_nil t23.not_empty]
    exact t23.arrival
  ¬∑ intro l hl hltwo
    by_cases in_12 : IsInfix l t12.stops
    ¬∑ sorry
    ¬∑ by_cases in_23 : IsInfix l t23.stops
      ¬∑ sorry
      ¬∑ sorry

end Ex3

end Exercises
