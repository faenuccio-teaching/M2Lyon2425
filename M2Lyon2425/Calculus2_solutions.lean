/-
  ## Calculus 2
  Credits.
  * Formalising Mathematics 2022 - 2024, K. Buzzard
  * Mathematics in Lean, J. Avigad, P. Massot
-/
import Mathlib.Analysis.SpecialFunctions.Integrals
import Mathlib.MeasureTheory.Integral.Bochner
import Mathlib.MeasureTheory.Integral.IntervalIntegral
import Mathlib.MeasureTheory.MeasurableSpace.Defs
import Mathlib.MeasureTheory.Constructions.Prod.Integral

/-

# Measure theory

## Sigma algebras.

A œÉ-algebra on a type `X` is a collection of subsets of `X` satisfying some
axioms, and in Lean you write it like this:

-/

section

-- let X be a set
variable (X : Type)

-- ...and let ùìê be a sigma-algebra on X
variable (ùìê : MeasurableSpace X)

/-

Note that `MeasurableSpace` is a *class*, so really we should be writing `[MeasurableSpace X]`,
meaning "let `X` be equipped once and for all with a sigma algebra which we won't give a name to".
But in this sheet we'll consider making them explicitly.

Let's do the following exercise. Show that if `A` is a subset of `X` then `{0,A,A·∂ú,X}`
is a sigma algebra on `X`.

-/
def genBy (A : Set X) : MeasurableSpace X where
  MeasurableSet' S := S = ‚àÖ ‚à® S = A ‚à® S = A·∂ú ‚à® S = ‚ä§
  measurableSet_empty := by
    exact Or.intro_left (‚àÖ = A ‚à® ‚àÖ = A·∂ú ‚à® ‚àÖ = ‚ä§) rfl
  measurableSet_compl := by
    intro s hs
    cases hs with
    | inl h =>
      right; right; right
      exact compl_eq_top.mpr h
    | inr h =>
      cases h with
      | inl h =>
        right; right; left
        exact congrArg compl h
      | inr h =>
        cases h with
        | inl h =>
          right; left
          rwa [compl_eq_comm, eq_comm]
        | inr h =>
          left
          exact Set.compl_empty_iff.mpr h
  measurableSet_iUnion := by
    intro f hf
    by_cases h_top : ‚àÉ i, f i = ‚ä§
    ¬∑ obtain ‚ü®i, hi‚ü© := h_top
      right; right; right
      rw [eq_top_iff]
      intro x _
      refine Set.mem_iUnion.mpr ‚ü®i, ?_‚ü©
      rwa [hi]
    ¬∑ by_cases h_A : ‚àÉ i, f i = A
      obtain ‚ü®i, hi‚ü© := h_A
      ¬∑ by_cases h_Ac : ‚àÉ j, f j = A·∂ú
        ¬∑ obtain ‚ü®j, hj‚ü© := h_Ac
          right; right; right
          rw [eq_top_iff]
          intro x _
          by_cases hx : x ‚àà A
          ¬∑ refine  Set.mem_iUnion.mpr ‚ü®i, ?_‚ü©
            rwa [hi]
          ¬∑ rw [‚Üê Set.mem_compl_iff] at hx
            refine  Set.mem_iUnion.mpr ‚ü®j, ?_‚ü©
            rwa [hj]
        ¬∑ have h_eq : ‚àÄ j, f j = A ‚à® f j = ‚àÖ := by
            push_neg at h_top h_Ac
            intro j
            by_contra h
            rw [not_or] at h
            specialize hf j
            aesop
          right; left
          ext x
          constructor
          ¬∑ intro hx
            obtain ‚ü®i, hi‚ü© := Set.mem_iUnion.mp hx
            cases h_eq i with
            | inl h =>
              rwa [h] at hi
            | inr h =>
              rw [h] at hi
              exact False.elim hi
          ¬∑ intro hx
            rw [Set.mem_iUnion]
            refine ‚ü®i, ?_‚ü©
            rwa [hi]
      ¬∑ by_cases h_Ac : ‚àÉ i, f i = A·∂ú
        ¬∑ have h_eq : ‚àÄ j, f j = A·∂ú ‚à® f j = ‚àÖ := by
            push_neg at h_top h_A
            intro j
            by_contra h
            rw [not_or] at h
            specialize hf j
            aesop
          right; right; left
          ext x
          constructor
          ¬∑ intro hx
            obtain ‚ü®i, hi‚ü© := Set.mem_iUnion.mp hx
            cases h_eq i with
            | inl h =>
                rwa [h] at hi
            | inr h =>
                rw [h] at hi
                exact False.elim hi
          ¬∑ intro h
            obtain ‚ü®i, hi‚ü© := h_Ac
            rw [Set.mem_iUnion]
            refine ‚ü®i, ?_‚ü©
            rwa [hi]
        ¬∑ have h_eq : ‚àÄ i, f i = ‚àÖ := by
            intro i
            specialize hf i
            refine Or.resolve_right hf ?_
            aesop
          aesop

-- An alternative approach to defining the sigma algebra generated by `{A}` is just
-- to use `MeasurableSpace.generateFrom`:
example (A : Set X) : MeasurableSpace X :=
  MeasurableSpace.generateFrom {A}

-- But the problem with that approach is that you don't get the actual sets
-- in the sigma algebra for free. Try this, to see what I mean!
example (A : Set X) :
    (MeasurableSpace.generateFrom {A}).MeasurableSet' =
    ({‚àÖ, A, A·∂ú, ‚ä§} : Set (Set X)) := by
  ext S
  constructor
  ¬∑ intro h
    induction h with
    | basic u hu =>
        right; left
        exact hu
    | empty =>
        left
        rfl
    | compl t _ ht =>
        rcases ht with (rfl | (rfl | (rfl | rfl)))
        ¬∑ right; right; right
          rw [Set.compl_empty, Set.top_eq_univ, Set.mem_singleton_iff]
        ¬∑ right; right; left
          rfl
        ¬∑ right; left
          rw [compl_compl]
        ¬∑ left
          rw [ Set.top_eq_univ, Set.compl_univ]
    | iUnion f _ hf =>
        -- Well, that's what we did above for `measurableSet_iUnion`; just need to copy the code :)
        sorry
  ¬∑ rintro (rfl | (rfl | (rfl | rfl)))
    ¬∑ exact (MeasurableSpace.generateFrom {A}).measurableSet_empty
    ¬∑ apply MeasurableSpace.GenerateMeasurable.basic
      rfl
    ¬∑ apply MeasurableSpace.GenerateMeasurable.compl
      apply MeasurableSpace.GenerateMeasurable.basic
      rfl
    ¬∑ convert MeasurableSpace.GenerateMeasurable.compl _
        (MeasurableSpace.generateFrom {A}).measurableSet_empty
      rw [Set.compl_empty, Set.top_eq_univ]


end

/-

# Measure theory

## More on sigma algebras.

-/

section

-- Intersection of sigma algebras is a sigma algebra
-- Let ùìê be a family of sigma algebras on a type `X`
variable (X : Type) (I : Type) (ùìê : I ‚Üí MeasurableSpace X)

-- Then their intersection is also a sigma algebra
open scoped MeasureTheory
-- to get notation `MeasurableSet[S] U` for "U is in the sigma algebra S"

example : MeasurableSpace X where
  MeasurableSet' U := ‚àÄ i, MeasurableSet[ùìê i] U
  measurableSet_empty := by
    intro i
    exact (ùìê i).measurableSet_empty
  measurableSet_compl := by
    intro s hs i
    exact (ùìê i).measurableSet_compl s (hs i)
  measurableSet_iUnion := by
    intro f hf i
    refine (ùìê i).measurableSet_iUnion _ ?_
    intro j
    exact hf j i

-- Lean knows that sigma algebras on X are a complete lattice
-- so you could also make it like this:
example : MeasurableSpace X :=
  ‚®Ö i, ùìê i

-- Sigma algebras are closed under countable intersection
-- Here, because there's only one sigma algebra involved,
-- I use the typeclass inference system to say "fix a canonical
-- sigma algebra on X" and just use that one throughout the question.
example (X : Type) [MeasurableSpace X]
    (f : ‚Ñï ‚Üí Set X) (hf : ‚àÄ n, MeasurableSet (f n)) :
    MeasurableSet (‚ãÇ n, f n) := by
  exact MeasurableSet.iInter hf

end

/-

# The extended nonnegative reals [0,‚àû]

The big dilemma when a designer is faced with "minor modifications"
of a standard type, is whether to just stick with the standard type
and make do, or whether to make a new type and then be faced with the
problem of having to make all the API for that type. Example: in measure
theory a key role is played by the "extended non-negative reals",
namely {x : ‚Ñù | 0 ‚â§ x} ‚à™ {‚àû}. In Lean these are their own type,
called `ENNReal`. There is a "scope" containing standard notation
associated for this type. Let's open it.

```lean
scoped[NNReal] notation "‚Ñù‚â•0" => NNReal
scoped[ENNReal] notation "‚Ñù‚â•0‚àû" => ENNReal
scoped[ENNReal] notation "‚àû" => (‚ä§ : ENNReal)
```
-/

section

open scoped ENNReal

#check ENNReal
-- #print notation ‚Ñù‚â•0‚àû
-- does not work in Lean4, but `go to definition` works like magic
#check ‚Ñù‚â•0‚àû -- [0,‚àû]
#check ‚àû -- it's the ‚àû in ‚Ñù‚â•0‚àû
-- What can we do with extended non-negative reals?
variable (a b : ‚Ñù‚â•0‚àû)

#check a + b

#check a - b -- surprising?
#check a * b -- what is 0 * ‚àû then?
#check a / b

-- is 1 / 0 = 0 or ‚àû? In ‚Ñù it's 0 but here there's another possibility
example : (0 : ‚Ñù‚â•0‚àû) * ‚àû = 0 := by
  exact zero_mul ‚ä§

example : (1 : ‚Ñù‚â•0‚àû) / 0 = ‚àû := by
  rw [ENNReal.div_eq_top]
  left
  constructor
  ¬∑ exact one_ne_zero
  ¬∑ rfl

example (a b c : ‚Ñù‚â•0‚àû) : (a + b) * c = a * c + b * c := by
  exact RightDistribClass.right_distrib a b c

end

section

open Filter

open scoped NNReal ENNReal MeasureTheory BigOperators Topology

namespace MeasureTheory

-- Let Œ© be a set equipped with a sigma algebra.
variable {Œ© : Type} [MeasurableSpace Œ©]

-- Now let's add a measure `Œº` on `Œ©`
variable {Œº : Measure Œ©}

/-
Try proving the following:
-/
example (S T : Set Œ©) (hS : Œº S ‚â† ‚àû) (hT : MeasurableSet T) :
    Œº (S ‚à™ T) = Œº S + Œº T - Œº (S ‚à© T) := by
  rw [‚Üê measure_union_add_inter S hT]
  rw [ENNReal.add_sub_cancel_right]
  have : S ‚à© T ‚äÜ S := by exact Set.inter_subset_left
  have := OuterMeasureClass.measure_mono Œº this
  exact ne_top_of_le_ne_top hS this

/-!
## Measurable functions

So far we've worked in the space `Œ©` though with all mathematical objects, we
want to map between them. In measure theory, the correct notion of maps is
measurable functions. If you have seen continuity in topology, they are quite
similar, namely, a function `f` between two measurable spaces is said to be
measurable if the preimages of all measurable sets along `f` is measurable.
-/


/-
*Remark*: while proving the above, you might have noticed I've added the
condition `hS` (think about what is a + ‚àû - ‚àû). In particular, subtraction in
extended non-negative reals (`‚Ñù‚â•0‚àû`) might not be what you expect,
e.g. 1 - 2 = 0 in `‚Ñù‚â•0‚àû`. For this reason, the above lemma is better phrased as
`Œº (S ‚à™ T) + Œº (S ‚à© T) = Œº S + Œº T` for which we can omit the condition `hS`.
-/

/-
If you go to the definition of measurable you will find what you expect.
However, of course, measure theory in Lean is a bit more complicated. As we
shall see, in contrast to maths, there are 3 additional notions of measurability
in mathlib. These are:
- `AEMeasurable`
- `StronglyMeasurable`
- `AEStronglyMeasurable`
The reasons for their existence is technical but TLDR: `ae_foo f` is the predicate
that `f` is almost everywhere equal to some function satisfying `foo` (see the
a.e. filter section) while `StronglyMeasurable f` is saying `f` is the limit
of a sequence of simple functions.

Alongside `measurable`, we also see them quite often in the mathlib, although
all you have to know is in most cases (range is metrizable and second-countable),
`Measurable` and `StronglyMeasurable` are equivalent.
-/
example : Measurable (id : Œ© ‚Üí Œ©) := by exact fun ‚¶Ét‚¶Ñ a ‚Ü¶ a

example {X Y Z : Type}
    [MeasurableSpace X] [MeasurableSpace Y] [MeasurableSpace Z]
    (f : X ‚Üí Y) (g : Y ‚Üí Z) (hg : Measurable g) (hf : Measurable f) :
    Measurable (g ‚àò f) := by
  exact Measurable.comp hg hf

/-!
## Integration

One of the primary motivations of measure theory is to introduce a more
satisfactory theory of integration. If you recall the definition of the
Darboux-Riemann integral, we cannot integrate the indicator function of
`‚Ñö ‚à© [0, 1]` despite, intuitively, the set of rationals in the unit interval
is much "smaller" (rationals is countable while the irrationals are not.
In contrast, measure theory allows us to construct the Lebesgue integral
which can deal with integrals such as this one.

Lean uses a even more general notion of integration known as Bochner integration
which allows us to integrate Banach-space valued functions. Its construction
is similar to the Lebesgue integral.

Read page 5-6 of https://arxiv.org/pdf/2102.07636.pdf
if you want to know the details.
-/

-- Suppose now `X` is another measurable space
variable {X : Type} [MeasurableSpace X]

-- and suppose it's also a Banach space (i.e. a vector space and a complete metric space)
variable [NormedAddCommGroup X] [NormedSpace ‚Ñù X] [CompleteSpace X]


-- If `f : Œ© ‚Üí X` is a function, then the integral of `f` is written as
-- `‚à´ x, f x ‚àÇŒº`. If you want to integrate over the set `s : set Œ©` then write
-- `‚à´ x in s, f x ‚àÇŒº`. -- use `\partial` to write `‚àÇ`
-- Try looking in mathlib
example {f g : Œ© ‚Üí X} (hf : Integrable f Œº) (hg : Integrable g Œº) :
    ‚à´ x, f x + g x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº + ‚à´ x, g x ‚àÇŒº := by
  exact integral_add hf hg

example (a : X) (s : Set Œ©) : ‚à´ _ in s, a ‚àÇŒº = (Œº s).toReal ‚Ä¢ a := by
  exact setIntegral_const a

-- Harder
example
    {f : Œ© ‚Üí ‚Ñù} (hf : Measurable f)
    (hint : Integrable f Œº) (hŒº : 0 < Œº {œâ | 0 < f œâ}) :
    (0 : ‚Ñù) < ‚à´ œâ in {œâ | 0 < f œâ}, f œâ ‚àÇŒº := by
  rw [MeasureTheory.integral_pos_iff_support_of_nonneg_ae]
  ¬∑ suffices (Œº.restrict {œâ | 0 < f œâ}) (Function.support f) = Œº {œâ | 0 < f œâ} by
      rwa [this]
    rw [Measure.restrict_apply]
    ¬∑ congr
      refine Set.inter_eq_self_of_subset_right ?_
      intro œâ hœâ
      refine Function.mem_support.mpr ?_
      exact hœâ.ne'
    ¬∑ exact measurableSet_support hf
  ¬∑ rw [EventuallyLE]
    rw [ae_restrict_iff']
    ¬∑ filter_upwards with x hx
      exact hx.le
    ¬∑ refine measurableSet_lt ?_ ?_
      ¬∑ exact measurable_const
      ¬∑ exact hf
  ¬∑ refine Integrable.mono_measure hint ?_
    exact Measure.restrict_le_self

/-!
## ae filter

Now we have come to a very important section of working with measure theory
in Lean.

In measure theory we have a notion known as almost everywhere (a.e.). In
probability this is known as almost surely however we will stick with
almost everywhere in this project. Namely, a predicate `P` on `Œ©` is said to
be true almost everywhere if the set for which `P` holds is co-null, i.e.
`Œº {œâ : Œ© | ¬¨ P œâ} = 0`.

As examples, we say:
- given functions `f, g`, `f` equals `g` a.e. if `Œº {œâ : Œ© | f œâ ‚â† g œâ} = 0`;
- `f` is less equal to `g` a.e. if `Œº {œâ : Œ© | ¬¨ f œâ ‚â§ g œâ} = 0` etc.

Often, showing that a property holds a.e. is the best we can do in
measure/probability theory.

In Lean, the notion of a.e. is handled by the `Measure.ae` filter.
Let's construct that filter ourselves.
-/


/-
*Remark* It's a common myth that Lebesgue integration is strictly better than
the Darboux-Riemann integral. This is true for integration on bounded intervals
though it is not true when considering improper integrals. A common example
for this is, while `‚à´ x in [0, ‚àû), sin x / x dx` is Darboux-Riemann integrable
(in fact it equals `œÄ / 2`) it is not Lebesgue integrable as
`‚à´ x in [0, ‚àû), |sin x / x| dx = ‚àû`.
-/
-- The set of the complements of neglectable sets is a filter
example (X : Type) [MeasurableSpace X] (Œº : Measure X) : Filter X :=
{ sets := { S | Œº (S·∂ú) = 0}
  univ_sets := by
    rw [Set.mem_setOf, Set.compl_univ, measure_empty]
  sets_of_superset := by
    intro S T hS hST
    rw [Set.mem_setOf]
    replace hST : T·∂ú ‚äÜ S·∂ú := by rwa [Set.compl_subset_compl]
    exact measure_mono_null hST hS
  inter_sets := by
    intro S T hS hT
    rw [Set.mem_setOf, Set.compl_inter]
    exact measure_union_null hS hT
}

-- say `f` and `g` are measurable functions `Œ© ‚Üí X`
variable (f g : Œ© ‚Üí X)

-- The following is a proposition that `f` and `g` are almost everywhere equal
-- it's **not** a proof that `f` and `g` are a.e. equal but simply a statement
example : Prop :=
  ‚àÄ·µê œâ ‚àÇŒº, f œâ = g œâ

-- Here's another example on how to state `f` is almost everywhere less equal
-- than `g`
-- To be able to formulate this we need a notion of inequality on `X` so we
-- will add the `LE` instance on `X`, i.e. equip `X` with a inequality
example [LE X] : Prop :=
  ‚àÄ·µê œâ ‚àÇŒº, f œâ ‚â§ g œâ

-- Since the above two cases come up quite often, there are special notations
-- for them. See if you can guess what they mean
example : Prop :=
  f =·µê[Œº] g

example [LE X] : Prop :=
  f ‚â§·µê[Œº] g

-- In general, if `P : Œ© ‚Üí Prop` is a predicate on `Œ©`, we write `‚àÄ·µê œâ ‚àÇŒº, P œâ`
-- for the statement that `P` holds a.e.
example (P : Œ© ‚Üí Prop) : Prop :=
  ‚àÄ·µê œâ ‚àÇŒº, P œâ

-- Sanity check: the above notation actually means what we think
example (P : Œ© ‚Üí Prop) : (‚àÄ·µê œâ ‚àÇŒº, P œâ) ‚Üî Œº ({œâ | P œâ}·∂ú) = 0 := by rfl

-- Here's a more convoluted example. See if you can figure what it means
example (f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù) (s : Set Œ©) :=
  ‚àÄ·µê œâ ‚àÇŒº.restrict s, ‚àÉ l : ‚Ñù, Tendsto (fun n ‚Ü¶ f n œâ) atTop (ùìù l)

-- Now to do some exercises: you will need to dig into the source code to see
-- what the definitions are and search for helpful lemmas
-- *Hint*: try out the `measurability / fun_prop` tactic. It should be able to solve simple
-- goals of the form `MeasurableSet s` and `Measurable f`
example (s : Set Œ©) (f g : Œ© ‚Üí ‚Ñù) (hf : Measurable f) (hg : Measurable g)
    (hfg : ‚àÄ œâ ‚àà s, f œâ = g œâ) : f =·µê[Œº.restrict s] g := by
  rw [EventuallyEq]
  rw [ae_restrict_iff]
  ¬∑ filter_upwards with œâ hœâ
    exact hfg œâ hœâ
  ¬∑ refine measurableSet_eq_fun ?_ ?_
    exact hf
    exact hg

example (f g h : Œ© ‚Üí ‚Ñù)
    (h‚ÇÅ : f ‚â§·µê[Œº] g) (h‚ÇÇ : f ‚â§·µê[Œº] h) : 2 * f ‚â§·µê[Œº] g + h := by
  filter_upwards [h‚ÇÅ, h‚ÇÇ] with x h1 h2
  simp_rw [Pi.mul_apply, Pi.ofNat_apply, Nat.cast_ofNat, Pi.add_apply, two_mul]
  gcongr

-- Just for fun, let's try to reprove the result above without using `filter_upwards`
example (f g h : Œ© ‚Üí ‚Ñù)
    (h‚ÇÅ : f ‚â§·µê[Œº] g) (h‚ÇÇ : f ‚â§·µê[Œº] h) : 2 * f ‚â§·µê[Œº] g + h := by
  rw [EventuallyLE, Filter.Eventually, mem_ae_iff] at h‚ÇÅ h‚ÇÇ ‚ä¢
  have : {x | (2 * f) x ‚â§ (g + h) x}·∂ú ‚äÜ {x | f x ‚â§ g x}·∂ú ‚à™ {x | f x ‚â§ h x}·∂ú := by
    rw [‚Üê Set.compl_inter, Set.compl_subset_compl]
    intro x hx
    simp_rw [Set.mem_setOf, Pi.mul_apply, Pi.ofNat_apply, Nat.cast_ofNat, Pi.add_apply, two_mul]
    gcongr
    ¬∑ exact hx.1
    ¬∑ exact hx.2
  refine measure_mono_null this ?_
  exact measure_union_null h‚ÇÅ h‚ÇÇ

example (f g : Œ© ‚Üí ‚Ñù) (h : f =·µê[Œº] g) (hg : ‚àÄ·µê œâ ‚àÇŒº, 2 * g œâ + 1 ‚â§ 0) :
    ‚àÄ·µê œâ ‚àÇŒº, f œâ ‚â§ -1 / 2 := by
  filter_upwards [h, hg] with œâ h1 h2
  rw [h1]
  linarith

example (f g : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù) (a b : ‚Ñù)
    (hf : ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ) atTop (ùìù a))
    (hg : ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => g n œâ) atTop (ùìù b)) :
    ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ + g n œâ) atTop (ùìù (a + b)) := by
  filter_upwards [hf, hg] with œâ h1 h2
  exact Tendsto.add h1 h2

/-
I hope that you found the above examples slightly annoying, especially the
third example: why can't we just `rw h`?! Of course, while we often do do so on
paper, rigourously, such a rewrite require some logic. Luckily, what we normally
do on paper is most often ok and we would like to do so in Lean as well. While
we can't directly rewrite almost everywhere equalities, we have the next best
thing: the `filter_upwards` tactic. See the tactic documentation here:
https://leanprover-community.github.io/mathlib_docs/tactics.html#filter_upwards

The `filter_upwards` tactic is much more powerful than simply rewriting a.e.
equalities and is helpful in many situations, e.g. the above second, third
and fourth examples are all easily solvable with this tactic. Let us see how
it works in action.
-/
-- Hover over each line and see how the goal changes
example (f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : Œ© ‚Üí ‚Ñù)
    (h‚ÇÅ : f‚ÇÅ ‚â§·µê[Œº] g‚ÇÅ) (h‚ÇÇ : f‚ÇÇ ‚â§·µê[Œº] g‚ÇÇ) : f‚ÇÅ + f‚ÇÇ ‚â§·µê[Œº] g‚ÇÅ + g‚ÇÇ := by
  filter_upwards [h‚ÇÅ, h‚ÇÇ]
  intro œâ hœâ‚ÇÅ hœâ‚ÇÇ
  exact add_le_add hœâ‚ÇÅ hœâ‚ÇÇ

-- Here's an even shorter proof using additional parameters of `filter_upwards`
example (f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : Œ© ‚Üí ‚Ñù) (h‚ÇÅ : f‚ÇÅ ‚â§·µê[Œº] g‚ÇÅ) (h‚ÇÇ : f‚ÇÇ ‚â§·µê[Œº] g‚ÇÇ) : f‚ÇÅ + f‚ÇÇ ‚â§·µê[Œº] g‚ÇÅ + g‚ÇÇ := by
  filter_upwards [h‚ÇÅ, h‚ÇÇ] with œâ hœâ‚ÇÅ hœâ‚ÇÇ using add_le_add hœâ‚ÇÅ hœâ‚ÇÇ

/-
Intuitively, what `filter_upwards` is doing is simply exploiting the fact that
the intersection of two full measure sets (i.e. complements are null) is also
a set of full measure. Thus, it suffices to work in their intersection instead.

Now, try the above examples again using the `filter_upwards` tactic.
-/
end MeasureTheory

open MeasureTheory intervalIntegral

open Interval
-- this introduces the notation `[[a, b]]` for the segment from `min a b` to `max a b`

example (a b : ‚Ñù) : (‚à´ x in a..b, x) = (b ^ 2 - a ^ 2) / 2 :=
  integral_id

example {a b : ‚Ñù} (h : (0 : ‚Ñù) ‚àâ [[a, b]]) : (‚à´ x in a..b, 1 / x) = Real.log (b / a) :=
  integral_one_div h

example (f : ‚Ñù ‚Üí ‚Ñù) (hf : Continuous f) (a b : ‚Ñù) : deriv (fun u ‚Ü¶ ‚à´ x : ‚Ñù in a..u, f x) b = f b :=
  (integral_hasStrictDerivAt_right (hf.intervalIntegrable _ _) (hf.stronglyMeasurableAtFilter _ _)
        hf.continuousAt).hasDerivAt.deriv


example {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} {f' : ‚Ñù ‚Üí ‚Ñù} (h : ‚àÄ x ‚àà [[a, b]], HasDerivAt f (f' x) x)
    (h' : IntervalIntegrable f' volume a b) : (‚à´ y in a..b, f' y) = f b - f a :=
  integral_eq_sub_of_hasDerivAt h h'

noncomputable section

open Set

variable {Œ± : Type*} [MeasurableSpace Œ±]

example : MeasurableSet (‚àÖ : Set Œ±) :=
  MeasurableSet.empty

example : MeasurableSet (univ : Set Œ±) :=
  MeasurableSet.univ

example {s : Set Œ±} (hs : MeasurableSet s) : MeasurableSet (s·∂ú) :=
  hs.compl

example : Encodable ‚Ñï := by infer_instance

example (n : ‚Ñï) : Encodable (Fin n) := by infer_instance

variable {Œπ : Type*} [Encodable Œπ]

example {f : Œπ ‚Üí Set Œ±} (h : ‚àÄ b, MeasurableSet (f b)) : MeasurableSet (‚ãÉ b, f b) :=
  MeasurableSet.iUnion h

example {f : Œπ ‚Üí Set Œ±} (h : ‚àÄ b, MeasurableSet (f b)) : MeasurableSet (‚ãÇ b, f b) :=
  MeasurableSet.iInter h

open MeasureTheory
variable {Œº : Measure Œ±}

example (s : Set Œ±) : Œº s = ‚®Ö (t : Set Œ±) (_ : s ‚äÜ t) (_ : MeasurableSet t), Œº t :=
  measure_eq_iInf s

example (s : Œπ ‚Üí Set Œ±) : Œº (‚ãÉ i, s i) ‚â§ ‚àë' i, Œº (s i) :=
  measure_iUnion_le s

example {f : ‚Ñï ‚Üí Set Œ±} (hmeas : ‚àÄ i, MeasurableSet (f i)) (hdis : Pairwise (Disjoint on f)) :
    Œº (‚ãÉ i, f i) = ‚àë' i, Œº (f i) :=
  Œº.m_iUnion hmeas hdis

example {P : Œ± ‚Üí Prop} : (‚àÄ·µê x ‚àÇŒº, P x) ‚Üî ‚àÄ·∂† x in ae Œº, P x :=
  Iff.rfl

end

noncomputable section

open MeasureTheory

variable {Œ± : Type*} [MeasurableSpace Œ±]
variable {Œº : Measure Œ±}

section
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E] {f : Œ± ‚Üí E}

example {f g : Œ± ‚Üí E} (hf : Integrable f Œº) (hg : Integrable g Œº) :
    ‚à´ a, f a + g a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº + ‚à´ a, g a ‚àÇŒº :=
  integral_add hf hg

example {s : Set Œ±} (c : E) : ‚à´ _ in s, c ‚àÇŒº = (Œº s).toReal ‚Ä¢ c :=
  setIntegral_const c

open Filter

example {F : ‚Ñï ‚Üí Œ± ‚Üí E} {f : Œ± ‚Üí E} (bound : Œ± ‚Üí ‚Ñù) (hmeas : ‚àÄ n, AEStronglyMeasurable (F n) Œº)
    (hint : Integrable bound Œº) (hbound : ‚àÄ n, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF n a‚Äñ ‚â§ bound a)
    (hlim : ‚àÄ·µê a ‚àÇŒº, Tendsto (fun n : ‚Ñï ‚Ü¶ F n a) atTop (ùìù (f a))) :
    Tendsto (fun n ‚Ü¶ ‚à´ a, F n a ‚àÇŒº) atTop (ùìù (‚à´ a, f a ‚àÇŒº)) :=
  tendsto_integral_of_dominated_convergence bound hmeas hint hbound hlim

example {Œ± : Type*} [MeasurableSpace Œ±] {Œº : Measure Œ±} [SigmaFinite Œº] {Œ≤ : Type*}
    [MeasurableSpace Œ≤] {ŒΩ : Measure Œ≤} [SigmaFinite ŒΩ] (f : Œ± √ó Œ≤ ‚Üí E)
    (hf : Integrable f (Œº.prod ŒΩ)) : ‚à´ z, f z ‚àÇ Œº.prod ŒΩ = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº := by
  exact integral_prod f hf

end
