/-
  ## Calculus 2
  Credits.
  * Formalising Mathematics 2022 - 2024, K. Buzzard
  * Mathematics in Lean, J. Avigad, P. Massot
-/
import Mathlib.Analysis.SpecialFunctions.Integrals
import Mathlib.MeasureTheory.Integral.Bochner
import Mathlib.MeasureTheory.Integral.IntervalIntegral
import Mathlib.MeasureTheory.MeasurableSpace.Defs

/-

# Measure theory

## Sigma algebras.

A œÉ-algebra on a type `X` is a collection of subsets of `X` satisfying some
axioms, and in Lean you write it like this:

-/

section

-- let X be a set
variable (X : Type)

-- ...and let ùìê be a sigma-algebra on X
variable (ùìê : MeasurableSpace X)

/-

Note that `MeasurableSpace` is a *class*, so really we should be writing `[MeasurableSpace X]`,
meaning "let `X` be equipped once and for all with a sigma algebra which we won't give a name to".
But in this sheet we'll consider making them explicitly.

Let's do the following exercise. Show that if `A` is a subset of `X` then `{0,A,A·∂ú,X}`
is a sigma algebra on `X`.

-/
def genBy (A : Set X) : MeasurableSpace X where
  MeasurableSet' S := S = ‚àÖ ‚à® S = A ‚à® S = A·∂ú ‚à® S = ‚ä§
  measurableSet_empty := sorry
  measurableSet_compl := sorry
  measurableSet_iUnion := sorry

-- An alternative approach to defining the sigma algebra generated by `{A}` is just
-- to use `MeasurableSpace.generateFrom`:
example (A : Set X) : MeasurableSpace X :=
  MeasurableSpace.generateFrom {A}

-- But the problem with that approach is that you don't get the actual sets
-- in the sigma algebra for free. Try this, to see what I mean!
example (A : Set X) :
    (MeasurableSpace.generateFrom {A}).MeasurableSet' =
    ({‚àÖ, A, A·∂ú, ‚ä§} : Set (Set X)) := by sorry

end

/-

# Measure theory

## More on sigma algebras.

-/

section

-- Intersection of sigma algebras is a sigma algebra
-- Let ùìê be a family of sigma algebras on a type `X`
variable (X : Type) (I : Type) (ùìê : I ‚Üí MeasurableSpace X)

-- Then their intersection is also a sigma algebra
open scoped MeasureTheory
-- to get notation `MeasurableSet[S] U` for "U is in the sigma algebra S"

example : MeasurableSpace X where
  MeasurableSet' U := ‚àÄ i, MeasurableSet[ùìê i] U
  measurableSet_empty := sorry
  measurableSet_compl := sorry
  measurableSet_iUnion := sorry

-- Lean knows that sigma algebras on X are a complete lattice
-- so you could also make it like this:
example : MeasurableSpace X :=
  ‚®Ö i, ùìê i

-- Sigma algebras are closed under countable intersection
-- Here, because there's only one sigma algebra involved,
-- I use the typeclass inference system to say "fix a canonical
-- sigma algebra on X" and just use that one throughout the question.
example (X : Type) [MeasurableSpace X]
    (f : ‚Ñï ‚Üí Set X) (hf : ‚àÄ n, MeasurableSet (f n)) :
    MeasurableSet (‚ãÇ n, f n) := sorry

end

/-

# The extended nonnegative reals [0,‚àû]

The big dilemma when a designer is faced with "minor modifications"
of a standard type, is whether to just stick with the standard type
and make do, or whether to make a new type and then be faced with the
problem of having to make all the API for that type. Example: in measure
theory a key role is played by the "extended non-negative reals",
namely {x : ‚Ñù | 0 ‚â§ x} ‚à™ {‚àû}. In Lean these are their own type,
called `ENNReal`. There is a "scope" containing standard notation
associated for this type. Let's open it.

```lean
scoped[ENNReal] notation "‚Ñù‚â•0‚àû" => ENNReal
scoped[ENNReal] notation "‚àû" => (‚ä§ : ENNReal)
```
-/

section

open scoped ENNReal

#check ENNReal
-- #print notation ‚Ñù‚â•0‚àû
-- does not work in Lean4, but `go to definition` works like magic
#check ‚Ñù‚â•0‚àû -- [0,‚àû]
#check ‚àû -- it's the ‚àû in ‚Ñù‚â•0‚àû
-- What can we do with extended non-negative reals?
variable (a b : ‚Ñù‚â•0‚àû)

#check a + b

#check a - b -- surprising?
#check a * b -- what is 0 * ‚àû then?
#check a / b

-- is 1 / 0 = 0 or ‚àû? In ‚Ñù it's 0 but here there's another possibility
example : (0 : ‚Ñù‚â•0‚àû) * ‚àû = 0 := sorry

example : (1 : ‚Ñù‚â•0‚àû) / 0 = ‚àû := sorry

example (a b c : ‚Ñù‚â•0‚àû) : (a + b) * c = a * c + b * c := sorry

end

section

open Filter

open scoped NNReal ENNReal MeasureTheory BigOperators Topology

namespace MeasureTheory

-- Let Œ© be a set equipped with a sigma algebra.
variable {Œ© : Type} [MeasurableSpace Œ©]

-- Now let's add a measure `Œº` on `Œ©`
variable {Œº : Measure Œ©}

/-
Try proving the following:
-/
example (S T : Set Œ©) (hS : Œº S ‚â† ‚àû) (hT : MeasurableSet T) :
    Œº (S ‚à™ T) = Œº S + Œº T - Œº (S ‚à© T) := sorry

/-!
## Measurable functions

So far we've worked in the space `Œ©` though with all mathematical objects, we
want to map between them. In measure theory, the correct notion of maps is
measurable functions. If you have seen continuity in topology, they are quite
similar, namely, a function `f` between two measurable spaces is said to be
measurable if the preimages of all measurable sets along `f` is measurable.
-/


/-
*Remark*: while proving the above, you might have noticed I've added the
condition `hS` (think about what is a + ‚àû - ‚àû). In particular, subtraction in
extended non-negative reals (`‚Ñù‚â•0‚àû`) might not be what you expect,
e.g. 1 - 2 = 0 in `‚Ñù‚â•0‚àû`. For this reason, the above lemma is better phrased as
`Œº (S ‚à™ T) + Œº (S ‚à© T) = Œº S + Œº T` for which we can omit the condition `hS`.
-/
/-
If you go to the definition of measurable you will find what you expect.
However, of course, measure theory in Lean is a bit more complicated. As we
shall see, in contrast to maths, there are 3 additional notions of measurability
in mathlib. These are:
- `AEMeasurable`
- `StronglyMeasurable`
- `AEStronglyMeasurable`
The reasons for their existence is technical but TLDR: `ae_foo f` is the predicate
that `f` is almost everywhere equal to some function satisfying `foo` (see the
a.e. filter section) while `StronglyMeasurable f` is saying `f` is the limit
of a sequence of simple functions.

Alongside `measurable`, we also see them quite often in the mathlib, although
all you have to know is in most cases (range is metrizable and second-countable),
`Measurable` and `StronglyMeasurable` are equivalent.
-/
example : Measurable (id : Œ© ‚Üí Œ©) := sorry

example {X Y Z : Type}
    [MeasurableSpace X] [MeasurableSpace Y] [MeasurableSpace Z]
    (f : X ‚Üí Y) (g : Y ‚Üí Z) (hg : Measurable g) (hf : Measurable f) :
    Measurable (g ‚àò f) := sorry

/-!
## Integration

One of the primary motivations of measure theory is to introduce a more
satisfactory theory of integration. If you recall the definition of the
Darboux-Riemann integral, we cannot integrate the indicator function of
`‚Ñö ‚à© [0, 1]` despite, intuitively, the set of rationals in the unit interval
is much "smaller" (rationals is countable while the irrationals are not.
In contrast, measure theory allows us to construct the Lebesgue integral
which can deal with integrals such as this one.

Lean uses a even more general notion of integration known as Bochner integration
which allows us to integrate Banach-space valued functions. Its construction
is similar to the Lebesgue integral.

Read page 5-6 of https://arxiv.org/pdf/2102.07636.pdf
if you want to know the details.
-/


-- Suppose now `X` is another measurable space
variable {X : Type} [MeasurableSpace X]

-- and suppose it's also a Banach space (i.e. a vector space and a complete metric space)
variable [NormedAddCommGroup X] [NormedSpace ‚Ñù X] [CompleteSpace X]

-- If `f : Œ© ‚Üí X` is a function, then the integral of `f` is written as
-- `‚à´ x, f x ‚àÇŒº`. If you want to integrate over the set `s : set Œ©` then write
-- `‚à´ x in s, f x ‚àÇŒº`.
-- Try looking in mathlib
example {f g : Œ© ‚Üí X} (hf : Integrable f Œº) (hg : Integrable g Œº) :
    ‚à´ x, f x + g x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº + ‚à´ x, g x ‚àÇŒº := sorry

example (a : X) (s : Set Œ©) : ‚à´ _ in s, a ‚àÇŒº = (Œº s).toReal ‚Ä¢ a := sorry

-- Harder
example
    {f : Œ© ‚Üí ‚Ñù} (hf : Measurable f)
    (hint : Integrable f Œº) (hŒº : 0 < Œº {œâ | 0 < f œâ}) :
    (0 : ‚Ñù) < ‚à´ œâ in {œâ | 0 < f œâ}, f œâ ‚àÇŒº := by
  sorry

/-!
## ae filter

Now we have come to a very important section of working with measure theory
in Lean.

In measure theory we have a notion known as almost everywhere (a.e.). In
probability this is known as almost surely however we will stick with
almost everywhere in this project. Namely, a predicate `P` on `Œ©` is said to
be true almost everywhere if the set for which `P` holds is co-null, i.e.
`Œº {œâ : Œ© | P œâ}·∂ú = 0`.

As examples, we say:
- given functions `f, g`, `f` equals `g` a.e. if `Œº {œâ : Œ© | f œâ ‚â† g œâ} = 0`;
- `f` is less equal to `g` a.e. if `Œº {œâ : Œ© | ¬¨ f œâ ‚â§ g œâ} = 0` etc.

Often, showing that a property holds a.e. is the best we can do in
measure/probability theory.

In Lean, the notion of a.e. is handled by the `Measure.ae` filter.
Let's construct that filter ourselves.
-/


/-
*Remark* It's a common myth that Lebesgue integration is strictly better than
the Darboux-Riemann integral. This is true for integration on bounded intervals
though it is not true when considering improper integrals. A common example
for this is, while `‚à´ x in [0, ‚àû), sin x / x dx` is Darboux-Riemann integrable
(in fact it equals `œÄ / 2`) it is not Lebesgue integrable as
`‚à´ x in [0, ‚àû), |sin x / x| dx = ‚àû`.
-/
example (X : Type) [MeasurableSpace X] (Œº : Measure X) : Filter X := sorry

-- say `f` and `g` are measurable functions `Œ© ‚Üí X`
variable (f g : Œ© ‚Üí X)

-- The following is a proposition that `f` and `g` are almost everywhere equal
-- it's **not** a proof that `f` and `g` are a.e. equal but simply a statement
example : Prop :=
  ‚àÄ·µê œâ ‚àÇŒº, f œâ = g œâ

-- Here's another example on how to state `f` is almost everywhere less equal
-- than `g`
-- To be able to formulate this we need a notion of inequality on `X` so we
-- will add the `LE` instance on `X`, i.e. equip `X` with a inequality
example [LE X] : Prop :=
  ‚àÄ·µê œâ ‚àÇŒº, f œâ ‚â§ g œâ

-- Since the above two cases come up quite often, there are special notations
-- for them. See if you can guess what they mean
example : Prop :=
  f =·µê[Œº] g

example [LE X] : Prop :=
  f ‚â§·µê[Œº] g

-- In general, if `P : Œ© ‚Üí Prop` is a predicate on `Œ©`, we write `‚àÄ·µê œâ ‚àÇŒº, P œâ`
-- for the statement that `P` holds a.e.
example (P : Œ© ‚Üí Prop) : Prop :=
  ‚àÄ·µê œâ ‚àÇŒº, P œâ

-- Sanity check: the above notation actually means what we think
example (P : Œ© ‚Üí Prop) : (‚àÄ·µê œâ ‚àÇŒº, P œâ) ‚Üî Œº ({œâ | P œâ}·∂ú) = 0 := by rfl

-- Here's a more convoluted example. See if you can figure what it means
example (f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù) (s : Set Œ©) :=
  ‚àÄ·µê œâ ‚àÇŒº.restrict s, ‚àÉ l : ‚Ñù, Tendsto (fun n ‚Ü¶ f n œâ) atTop (ùìù l)

-- Now to do some exercises: you will need to dig into the source code to see
-- what the definitions are and search for helpful lemmas
-- *Hint*: try out the `measurability` tactic. It should be able to solve simple
-- goals of the form `MeasurableSet s` and `Measurable f`
example (s : Set Œ©) (f g : Œ© ‚Üí ‚Ñù) (hf : Measurable f) (hg : Measurable g)
    (hfg : ‚àÄ œâ ‚àà s, f œâ = g œâ) : f =·µê[Œº.restrict s] g := sorry

example (f g h : Œ© ‚Üí ‚Ñù)
    (h‚ÇÅ : f ‚â§·µê[Œº] g) (h‚ÇÇ : f ‚â§·µê[Œº] h) : 2 * f ‚â§·µê[Œº] g + h := sorry

example (f g : Œ© ‚Üí ‚Ñù) (h : f =·µê[Œº] g) (hg : ‚àÄ·µê œâ ‚àÇŒº, 2 * g œâ + 1 ‚â§ 0) :
    ‚àÄ·µê œâ ‚àÇŒº, f œâ ‚â§ -1 / 2 := sorry

example (f g : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù) (a b : ‚Ñù)
    (hf : ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ) atTop (ùìù a))
    (hg : ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => g n œâ) atTop (ùìù b)) :
    ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ + g n œâ) atTop (ùìù (a + b)) := sorry

/-
I hope that you found the above examples slightly annoying, especially the
third example: why can't we just `rw h`?! Of course, while we often do do so on
paper, rigourously, such a rewrite require some logic. Luckily, what we normally
do on paper is most often ok and we would like to do so in Lean as well. While
we can't directly rewrite almost everywhere equalities, we have the next best
thing: the `filter_upwards` tactic. See the tactic documentation here:
https://leanprover-community.github.io/mathlib_docs/tactics.html#filter_upwards

The `filter_upwards` tactic is much more powerful than simply rewriting a.e.
equalities and is helpful in many situations, e.g. the above second, third
and fourth examples are all easily solvable with this tactic. Let us see how
it works in action.
-/
-- Hover over each line and see how the goal changes
example (f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : Œ© ‚Üí ‚Ñù)
    (h‚ÇÅ : f‚ÇÅ ‚â§·µê[Œº] g‚ÇÅ) (h‚ÇÇ : f‚ÇÇ ‚â§·µê[Œº] g‚ÇÇ) : f‚ÇÅ + f‚ÇÇ ‚â§·µê[Œº] g‚ÇÅ + g‚ÇÇ := by
  filter_upwards [h‚ÇÅ, h‚ÇÇ]
  intro œâ hœâ‚ÇÅ hœâ‚ÇÇ
  exact add_le_add hœâ‚ÇÅ hœâ‚ÇÇ

-- Here's an even shorter proof using additional parameters of `filter_upwards`
example (f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : Œ© ‚Üí ‚Ñù) (h‚ÇÅ : f‚ÇÅ ‚â§·µê[Œº] g‚ÇÅ) (h‚ÇÇ : f‚ÇÇ ‚â§·µê[Œº] g‚ÇÇ) : f‚ÇÅ + f‚ÇÇ ‚â§·µê[Œº] g‚ÇÅ + g‚ÇÇ := by
  filter_upwards [h‚ÇÅ, h‚ÇÇ] with œâ hœâ‚ÇÅ hœâ‚ÇÇ using add_le_add hœâ‚ÇÅ hœâ‚ÇÇ

/-
Intuitively, what `filter_upwards` is doing is simply exploiting the fact that
the intersection of two full measure sets (i.e. complements are null) is also
a set of full measure. Thus, it suffices to work in their intersection instead.

Now, try the above examples again using the `filter_upwards` tactic.
-/
end MeasureTheory

open MeasureTheory intervalIntegral

open Interval
-- this introduces the notation `[[a, b]]` for the segment from `min a b` to `max a b`

example (a b : ‚Ñù) : (‚à´ x in a..b, x) = (b ^ 2 - a ^ 2) / 2 :=
  integral_id

example {a b : ‚Ñù} (h : (0 : ‚Ñù) ‚àâ [[a, b]]) : (‚à´ x in a..b, 1 / x) = Real.log (b / a) :=
  integral_one_div h

example (f : ‚Ñù ‚Üí ‚Ñù) (hf : Continuous f) (a b : ‚Ñù) : deriv (fun u ‚Ü¶ ‚à´ x : ‚Ñù in a..u, f x) b = f b :=
  (integral_hasStrictDerivAt_right (hf.intervalIntegrable _ _) (hf.stronglyMeasurableAtFilter _ _)
        hf.continuousAt).hasDerivAt.deriv

example {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} {f' : ‚Ñù ‚Üí ‚Ñù} (h : ‚àÄ x ‚àà [[a, b]], HasDerivAt f (f' x) x)
    (h' : IntervalIntegrable f' volume a b) : (‚à´ y in a..b, f' y) = f b - f a :=
  integral_eq_sub_of_hasDerivAt h h'

noncomputable section

open Set

variable {Œ± : Type*} [MeasurableSpace Œ±]

example : MeasurableSet (‚àÖ : Set Œ±) :=
  MeasurableSet.empty

example : MeasurableSet (univ : Set Œ±) :=
  MeasurableSet.univ

example {s : Set Œ±} (hs : MeasurableSet s) : MeasurableSet (s·∂ú) :=
  hs.compl

example : Encodable ‚Ñï := by infer_instance

example (n : ‚Ñï) : Encodable (Fin n) := by infer_instance

variable {Œπ : Type*} [Encodable Œπ]

example {f : Œπ ‚Üí Set Œ±} (h : ‚àÄ b, MeasurableSet (f b)) : MeasurableSet (‚ãÉ b, f b) :=
  MeasurableSet.iUnion h

example {f : Œπ ‚Üí Set Œ±} (h : ‚àÄ b, MeasurableSet (f b)) : MeasurableSet (‚ãÇ b, f b) :=
  MeasurableSet.iInter h

open MeasureTheory
variable {Œº : Measure Œ±}

example (s : Set Œ±) : Œº s = ‚®Ö (t : Set Œ±) (_ : s ‚äÜ t) (_ : MeasurableSet t), Œº t :=
  measure_eq_iInf s

example (s : Œπ ‚Üí Set Œ±) : Œº (‚ãÉ i, s i) ‚â§ ‚àë' i, Œº (s i) :=
  measure_iUnion_le s

example {f : ‚Ñï ‚Üí Set Œ±} (hmeas : ‚àÄ i, MeasurableSet (f i)) (hdis : Pairwise (Disjoint on f)) :
    Œº (‚ãÉ i, f i) = ‚àë' i, Œº (f i) :=
  Œº.m_iUnion hmeas hdis

example {P : Œ± ‚Üí Prop} : (‚àÄ·µê x ‚àÇŒº, P x) ‚Üî ‚àÄ·∂† x in ae Œº, P x :=
  Iff.rfl

end

noncomputable section

open MeasureTheory

variable {Œ± : Type*} [MeasurableSpace Œ±]
variable {Œº : Measure Œ±}

section
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E] {f : Œ± ‚Üí E}

example {f g : Œ± ‚Üí E} (hf : Integrable f Œº) (hg : Integrable g Œº) :
    ‚à´ a, f a + g a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº + ‚à´ a, g a ‚àÇŒº :=
  integral_add hf hg

example {s : Set Œ±} (c : E) : ‚à´ x in s, c ‚àÇŒº = (Œº s).toReal ‚Ä¢ c :=
  setIntegral_const c

open Filter

example {F : ‚Ñï ‚Üí Œ± ‚Üí E} {f : Œ± ‚Üí E} (bound : Œ± ‚Üí ‚Ñù) (hmeas : ‚àÄ n, AEStronglyMeasurable (F n) Œº)
    (hint : Integrable bound Œº) (hbound : ‚àÄ n, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF n a‚Äñ ‚â§ bound a)
    (hlim : ‚àÄ·µê a ‚àÇŒº, Tendsto (fun n : ‚Ñï ‚Ü¶ F n a) atTop (ùìù (f a))) :
    Tendsto (fun n ‚Ü¶ ‚à´ a, F n a ‚àÇŒº) atTop (ùìù (‚à´ a, f a ‚àÇŒº)) :=
  tendsto_integral_of_dominated_convergence bound hmeas hint hbound hlim

example {Œ± : Type*} [MeasurableSpace Œ±] {Œº : Measure Œ±} [SigmaFinite Œº] {Œ≤ : Type*}
    [MeasurableSpace Œ≤] {ŒΩ : Measure Œ≤} [SigmaFinite ŒΩ] (f : Œ± √ó Œ≤ ‚Üí E)
    (hf : Integrable f (Œº.prod ŒΩ)) : ‚à´ z, f z ‚àÇ Œº.prod ŒΩ = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº := by
  sorry

end
