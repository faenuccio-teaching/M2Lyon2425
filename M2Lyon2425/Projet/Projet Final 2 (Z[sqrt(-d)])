import Mathlib.Algebra.Group.Nat
--import Mathlib.Data.Set.Basic
--import Mathlib.Data.Set.Operations
--import Mathlib.Order.SetNotation
import Mathlib.Tactic
--import Mathlib.Data.Real.Basic
import Mathlib.GroupTheory.Perm.Basic
--import Mathlib.Algebra.EuclideanDomain.Basic

variable (d:ℤ)




/--Projet LEAN :

1) Définir l'anneau Z[sqrt(d)] avec ses opérations
2) Montrer que Z[sqrt(d)] est un anneau commutatif
3) Pour quels d (d<0) est-ce que Z[sqrt(d)] est euclidien ?

-/







--Etape 1 : On définit l'anneau Z[sqrt(d)] avec ses opérations

@[ext]
structure MonAnneau (d : ℤ) where
  re : ℤ
  im : ℤ

instance : Zero (MonAnneau d) :=
  ⟨ ⟨ 0,0 ⟩ ⟩

instance : One (MonAnneau d) :=
  ⟨ ⟨ 1, 0⟩ ⟩

instance : Add (MonAnneau d) :=
  ⟨ fun x y ↦ ⟨ x.re + y.re, x.im + y.im⟩ ⟩

instance : Neg (MonAnneau d) :=
  ⟨ fun x ↦ ⟨ -x.re, -x.im⟩ ⟩

instance : Mul (MonAnneau d) where
  mul := fun x y ↦  ⟨ x.re * y.re - d* x.im * y.im, x.re * y.im + x.im * y.re⟩





--defs

theorem zero_def : (0 : (MonAnneau d)) = ⟨0, 0⟩  :=
  rfl
theorem one_def : (1 : (MonAnneau d)) = ⟨1, 0⟩  :=
  rfl
theorem add_def (x y : (MonAnneau d)) : x + y = ⟨ x.re + y.re, x.im + y.im⟩  :=
  rfl
theorem neg_def (x : (MonAnneau d)) : -x = ⟨ -x.re, -x.im ⟩  :=
  rfl
theorem mul_def (x y : (MonAnneau d)) :
  x * y = ⟨ x.re * y.re - d * x.im * y.im, x.re * y.im + x.im * y.re⟩ :=
  rfl







-- Etape 2 : On montre que Z[sqrt(d)] est un anneau commutatif


@[simp]
theorem zero_re : (0 : (MonAnneau d)).re = 0 := by
  rfl
@[simp]
theorem zero_im : (0 : (MonAnneau d)).im = 0 := by
  rfl
@[simp]
theorem one_re : (1 : (MonAnneau d)).re = 1 := by
  rfl
@[simp]
theorem one_im : (1 : (MonAnneau d)).im = 0 := by
  rfl
@[simp]
theorem add_re (x y : (MonAnneau d)) : (x + y).re = x.re + y.re := by
  rfl
@[simp]
theorem add_im (x y : (MonAnneau d)) : (x + y).im = x.im + y.im := by
  rfl
@[simp]
theorem neg_re (x : (MonAnneau d)) : (-x).re = -x.re := by
  rfl
@[simp]
theorem neg_im (x : (MonAnneau d)) : (-x).im = -x.im := by
  rfl
@[simp]
theorem mul_re (x y : (MonAnneau d)) : (x * y).re = x.re * y.re - d*x.im * y.im := by
  rw[mul_def]
@[simp]
theorem mul_im (x y : (MonAnneau d)) : (x * y).im = x.re * y.im + x.im * y.re := by
  rfl

lemma MonAnneau_add_assoc (d : ℤ) :
    ∀ (a b c : MonAnneau d), a + b + c = a + (b + c) := by
  intro a b c
  ext
  · rw[add_re]
    rw[add_re]
    rw[add_re]
    rw[add_re]
    rw[add_assoc]
  · rw[add_im]
    rw[add_im]
    rw[add_im]
    rw[add_im]
    rw[add_assoc]

lemma MonAnneau_zero_add (d : ℤ) :
    ∀ (a : MonAnneau d), 0 + a = a := by
  intro a
  ext
  · rw[add_re]
    rw[zero_re]
    rw[zero_add]
  · rw[add_im]
    rw[zero_im]
    rw[zero_add]

lemma MonAnneau_add_zero (d : ℤ) :
    ∀ (a : MonAnneau d), a + 0 = a := by
  intro a
  ext
  · rw[add_re]
    rw[zero_re]
    rw[add_zero]
  · rw[add_im]
    rw[zero_im]
    rw[add_zero]

instance instCommRing_MonAnneau : CommRing (MonAnneau d) where
  zero := 0
  one := 1
  add := (· + ·)
  neg x := -x
  mul := (· * ·)
  nsmul := nsmulRec
  zsmul := zsmulRec
  add_assoc := MonAnneau_add_assoc d
  zero_add := MonAnneau_zero_add d
  add_zero := MonAnneau_add_zero d



  /-
  neg_add_cancel := by
    intro a
    ext
    · simp only [add_re]
      simp only [neg_re]
      simp only [neg_add_cancel]
      rw[zero_re]
    · simp only [add_im]
      simp only [neg_im]
      simp only [neg_add_cancel]
      rw[zero_im]
  add_comm := by
    intro a b
    ext
    · rw[add_re]
      rw[add_re]
      rw[add_comm]
    · rw[add_im]
      rw[add_im]
      rw[add_comm]
  mul_assoc := by
    intro a b c
    ext
    · simp only[mul_re]
      rw[mul_im]
      rw[mul_im]
      rw[mul_assoc]
      rw[mul_assoc]
      rw[mul_assoc]
      rw[mul_assoc]
      ring
    · simp only[mul_im]
      rw[mul_re]
      rw[mul_re]
      rw[mul_assoc]
      rw[mul_assoc]
      ring
  one_mul := by
    intro a
    ext
    · rw[mul_re]
      rw[one_re]
      rw[one_mul]
      rw[one_im]
      rw[mul_zero]
      rw[zero_mul]
      rw[sub_zero]
    · rw[mul_im]
      rw[one_re]
      rw[one_mul]
      rw[one_im]
      rw[zero_mul]
      rw[add_zero]
  mul_one := by
    intro a
    ext
    · rw[mul_re]
      rw[one_re]
      rw[mul_one]
      rw[one_im]
      rw[mul_zero]
      rw[sub_zero]
    · rw[mul_im]
      rw[one_im]
      rw[mul_zero]
      rw[one_re]
      rw[mul_one]
      rw[zero_add]
  left_distrib := by
    intro a b c
    ext
    · rw[mul_re]
      rw[add_re]
      rw[add_im]
      rw[add_re]
      rw[mul_re]
      rw[mul_re]
      ring
    · rw[mul_im]
      rw[add_im]
      rw[add_im]
      rw[mul_im]
      rw[mul_im]
      rw[add_re]
      rw[left_distrib]
      rw[left_distrib]
      ring
      --rw[mul_im]      rw[add_im]      rw[add_im]      rw[mul_im]      rw[mul_im]      rw[add_re]
  right_distrib := by
    intro a b c
    ext
    · simp
      ring
      --rw[mul_re]       rw[add_re]      rw[add_im]      rw[add_re]      rw[mul_re]      rw[mul_re]
    · simp
      ring
  mul_comm := by
    intro a b
    ext
    · simp only [mul_re]
      ring
    · simp only [mul_im]
      ring
  zero_mul := by
    intro a
    ext
    · rw[mul_re]
      simp only [zero_re, zero_im]
      rw[zero_mul]
      rw[mul_zero]
      rw[zero_mul]
      rw[sub_self]
    · rw[mul_im]
      simp only[zero_re, zero_im]
      rw[zero_mul]
      rw[zero_mul]
      rw[add_zero]
  mul_zero:=by
    intro a
    ext
    · simp
      -- rw[mul_re] rw[zero_re] rw[zero_im]      rw[mul_zero]      rw[mul_zero]      rw[sub_self]
    · simp
      --rw[mul_im] rw[zero_im] rw[mul_zero] rw[zero_re] rw[add_zero]-/




--Etape 3 : Pour quels d (d<0), est-ce que Z[sqrt(d)] est un anneau Euclidien ?

--On montre que Z[sqrt(d)] contient au moins 2 éléments
instance instNontrivial : Nontrivial (MonAnneau d) := by
  use 0, 1
  rw [Ne, MonAnneau.ext_iff]
  simp



--> Si d=-1 : Livre


example (a b : ℤ) : a = b * (a / b) + a % b :=
  Eq.symm (Int.ediv_add_emod a b)
example (a b : ℤ) : b≠ 0 → 0 ≤ a % b :=
  Int.emod_nonneg a
example (a b : ℤ) : b ≠ 0 → a % b < |b| :=
  Int.emod_lt a

def div' (a b : ℤ) :=
(a + b / 2) / b
def mod' (a b : ℤ) :=
(a + b / 2) % b - b / 2
theorem div'_add_mod' (a b : ℤ) : b * div' a b + mod' a b = a := by
  rw [div', mod']
  linarith [Int.ediv_add_emod (a + b / 2) b]
theorem abs_mod'_le (a b : ℤ) (h : 0 < b) : |mod' a b| ≤ b / 2 := by
  rw [mod', abs_le]
  constructor
  · linarith [Int.emod_nonneg (a + b / 2) h.ne']
  have := Int.emod_lt_of_pos (a + b / 2) h
  have := Int.ediv_add_emod b 2
  have := Int.emod_lt_of_pos b zero_lt_two
  linarith

theorem mod'_eq (a b : ℤ) : mod' a b = a - b * div' a b := by
  linarith [div'_add_mod' a b]

@[simp]
def norm (x : (MonAnneau (-1))) :=
  x.re ^ 2 + x.im ^ 2




@[simp]
theorem norm_nonneg_1 (x : (MonAnneau (-1))) : 0 ≤ norm x := by
  simp
  suffices : x.re^2 ≥ 0 ∧ x.im^2 ≥ 0
  · cases this with
  | intro left right =>
    refine Int.add_nonneg left ?intro.hb
    exact right
  · constructor
    · exact sq_nonneg x.re
    · exact sq_nonneg x.im




@[simp]
def conj (x : (MonAnneau (-1))) : (MonAnneau (-1)) :=
  ⟨x.re, -x.im⟩
@[simp]
theorem conj_re (x : (MonAnneau (-1))) : (conj x).re = x.re :=
rfl
@[simp]
theorem conj_im (x : (MonAnneau (-1))) : (conj x).im = -x.im :=
rfl
theorem norm_conj (x : (MonAnneau (-1))) : norm (conj x) = norm x := by
  simp

instance : Div (MonAnneau (-1)) :=
⟨fun x y ↦ ⟨div' (x * conj y).re (norm y), Int.div (x * conj y).im (norm y)⟩⟩

instance : Mod (MonAnneau (-1)) :=
  ⟨fun x y ↦ x - y * (x / y)⟩


--> Si d=-2 : Un des sujets d'Agreg


@[simp]
def Norm_2 (a: (MonAnneau (-2))) :=
  a.re^2+2*a.im^2

@[simp]
theorem norm_nonneg_MonAnneau (z : (MonAnneau (-2))) : 0 ≤ Norm_2 z := by
  simp
  suffices : z.re^2 ≥ 0 ∧ z.im^2 ≥ 0
  · cases this with
  | intro left right =>
    refine Int.add_nonneg left ?intro.hb
    simp
    exact right
  · constructor
    · exact sq_nonneg z.re
    · exact sq_nonneg z.im


instance : Star (MonAnneau d) where
  star z := ⟨z.1, -z.2⟩


@[simp]
theorem star_re (z : (MonAnneau d)) : (star z).re = z.re :=
  rfl
@[simp]
theorem star_im (z : (MonAnneau d)) : (star z).im = -z.im :=
  rfl

instance : StarRing (MonAnneau d) where
  star_involutive x := by
    ext
    · simp
    · simp
  star_mul a b := by
    ext
    · simp
      ring
    · simp
      ring
  star_add a b := by
    ext
    · simp
    · simp
      ring



def norm_d (z : (MonAnneau d)) : ℤ :=
  z.re^2 + d * z.im^2

--Quotient :
instance quotient : Div (MonAnneau (-2)) where
  div := by
    intros x y
    let Norme_y := (Norm_2 y : ℚ)⁻¹
    let y_barre := star y
    exact ⟨round ((x * y_barre).re * Norme_y : ℚ), round ((x * y_barre).im * Norme_y : ℚ)⟩

lemma quotient_def : quotient.div = fun x y ↦
    let Norme_y := (Norm_2 y : ℚ)⁻¹;
    let y_barre := star y;
    { re := round ((x * y_barre).re * Norme_y), im := round ((x * y_barre).im * Norme_y) } := by rfl

 #print quotient

 --Remainder :
instance remainder : Mod (MonAnneau (-2)) where
  mod := fun x y => x - y * (x / y)

lemma remainder_def : remainder.mod = fun x y => x - y * (x / y) := by rfl

instance : EuclideanDomain (MonAnneau (-2)) where
  quotient := quotient.div
  remainder := remainder.mod
  quotient_mul_add_remainder_eq:= by
    intros x y
    simp [quotient_def, remainder_def]
    have : y * (x / y) = x := by
      change y * (quotient.div x y) = x
      rw [quotient_def]
      dsimp
      rw [mul_def]
      ext
      · simp only [Int.reduceNeg, mul_re, star_re, neg_mul, star_im, mul_neg, neg_neg,
        Int.cast_sub, Int.cast_mul, Int.cast_ofNat, Int.cast_add, Int.cast_pow, Int.cast_neg,
        sub_neg_eq_add]
        sorry
      · dsimp
        sorry
    rw [this]
    simp only [Int.reduceNeg, mul_re, star_re, neg_mul, star_im, mul_neg, neg_neg, Int.cast_sub,
      Int.cast_mul, Int.cast_ofNat, Int.cast_add, Int.cast_pow, Int.cast_neg, sub_self, add_zero]
    rw [mul_def]
    dsimp
    ext
    · dsimp
      sorry
    · dsimp
      sorry
  quotient_zero := by
    intro x
    rw [quotient_def]
    dsimp
    ext
    · simp only [Int.reduceNeg, star_zero, mul_zero, zero_re, Int.cast_zero, inv_zero, round_zero]
    · simp only [Int.reduceNeg, mul_zero, add_zero, Int.cast_zero, inv_zero, round_zero, zero_im]
  r := by
    intros a b
    by_cases h : Norm_2 (remainder.mod a b) ≤ Norm_2 b
    exact True
    exact False
  r_wellFounded := sorry
  remainder_lt := by
    intros a b hb
    dsimp
    have : (Mod.mod (Mod.mod a b) b).re ^ 2 + 2 * (Mod.mod (Mod.mod a b) b).im ^ 2 ≤ b.re ^ 2 + 2 * b.im ^ 2 := by
      have : (Mod.mod (Mod.mod a b) b).re = (Mod.mod a b).re := sorry
      rw [this]
      have : (Mod.mod (Mod.mod a b) b).im = (Mod.mod a b).im := sorry
      rw [this]
      sorry
    simp only [this, ↓reduceIte]
  mul_left_not_lt := by
    intros a b hb h
    have : ¬(Norm_2 (Mod.mod (a * b) a) ≤ Norm_2 a) := by
      intro h₂
      have : Mod.mod (a * b) a = b := sorry
      rw [this] at h₂
      sorry
    simp only [this, ↓reduceDIte] at h

--Si d<=-3 :

def sqrt_moins_d (d : ℤ) : MonAnneau d :=
  ⟨0, 1⟩

def mul_two_MonAnneau {d : ℤ} (x : MonAnneau d) : MonAnneau d :=
  ⟨2 * x.re, 2 * x.im⟩


--theorem Non_factoriel (hd : d≤ (-3)) : ¬ UFD (MonAnneau d) :=

/--Idée de la preuve : Regarder selon la parité de d
On veut montrer que Z[sqrt(-d)] n'est pas factoriel pour d≤-3

Synthaxe pour montrer qu'un anneau n'est pas factoriel sur Lean ?

-/
